<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            max-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevents body scrollbars */
            display: flex;
            flex-direction: column;
        }
        
        .inline-block-child {
            display: inline-block;
        }

        #control_panel {
            overflow: visible;
        }

        #TreeData {
            white-space: nowrap; /*prevents line wrapping inside*/
            overflow-x: auto;
            box-sizing: border-box;
        }

        #ClusterInfo {
          position: relative;
          overflow: auto
        }

        
        #resizer-bar {
            flex: 0 0 5px !important;
            min-height: 5px;
        }

        #metadata_wrapper{
            width:fit-content;
        }

        #metadata_filter, #metadata_paginate{ /*Search and clear filters button of metadata table */
            position: sticky;
            right: 0;
        }

        #metadata_length { /*show x entries filter of metadata table */
            position: sticky;
            left: 0;  
        }
       
        
        .tree-svg {
          height: auto;
          font: 10px sans-serif;
          user-select: auto;
          overflow: visible;
          margin-left: 1em; 

        }

        .row.no-wrap {
            flex-wrap: nowrap; /*prevents the TreeData div with the svg tree to wrap around*/
        }

        .scrollbar-window{
            overflow: auto;
            /*overflow-x: scroll;*/
            /*height: 200px;*/
        }

        input[type="file"] {
            /* Hide the button in boot strap*/
            display: none;
        }

        
        .input-group-text:hover {
            filter: brightness(80%);
        }

        .legend-element:hover {
            filter: opacity(0.5);
            cursor: pointer;
        }
   

        .scale-bar {
            cursor: move;
            visibility: visible;
            font-family: monospace, monospace;
        }

        /*This creates flash effect when the user finishes editing a metadata cell.*/
        .flash {
            animation: flashHighlight 0.5s ease;
          
        }  
        

        @keyframes flashHighlight {
            from { background-color: red; }
            to   { background-color: transparent; }
        }

        @keyframes spin {
            0% {
                transform: rotate(0);
            }
            25% {
                transform: rotate(-0.05turn);
            }

            50% {
                transform: rotate(0);
            }

            75% {
                transform: rotate(0.05turn);
            }

            100% {
                transform: translateY(0);
            }
        }

        @keyframes  updown {
            0% {
                transform: translateY(-10%);
            }

            50% {
                transform: translateY(10%);
            }

            100% {
                transform: translateY(-10%);
            }
        }

        .icon-spin {
            animation: spin 1s linear infinite;
        }

        .icon-jump {
            animation: updown 1s ease infinite
        }


        /* dataTables Search input box */
    
        .dataTables_filter {
            position: relative;
        }
        .dataTables_wrapper .dataTables_filter input{
            border-radius: 20px !important;
            margin-top: 1px;
        }
    
        .dataTables_filter input {
            width: 250px;
            height: 26px;
            background: #fcfcfc;
            box-shadow: 0 0 3px #ccc, 0 10px 15px #ebebeb inset;
            text-indent: 10px;
        }
    
        .dataTables_filter .fa-search {
            position: absolute;
            top: 10px;
            left: auto;
            right: 10px;
        }

        .fade-out-dropdown-menu {
            opacity: 0;
            transition: opacity 2s ease;
        }
        
        .leaf-node {
          font-family: monospace, monospace;
          white-space-collapse: preserve;
        }

        .inner-node {
          font-family: monospace, monospace;
          white-space-collapse: preserve;
        }
        
        .leaf-node-label {

          font-family: monospace, monospace;
          white-space-collapse: preserve;
      }



    </style>
    <meta charset="UTF-8">
    <meta name="application-name" content="ArborView">
    <meta name="version" content="0.1.3"> <!-- Update version as needed -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ArborView</title> 

    <!-- Link to your favicon.ico file -->
    <link rel="icon" href="favicon.ico?v=1" type="image/x-icon">
    <link rel="shortcut icon" href="favicon.ico?v=1" type="image/x-icon"> 


    <!-- Random colour library for creating some nice highlighted trees  https://github.com/davidmerfield/randomColor   -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.6.1/randomColor.min.js" integrity="sha512-vPeZ7JCboHcfpqSx5ZD+/jpEhS4JpXxfz9orSvAPPj0EKUVShU2tgy7XkU+oujBJKnWmu4hU7r9MMQNWPfXsYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!--script src="https://d3js.org/d3.v6.min.js"></script--> <!--sometimes does not load so using this more reliable url-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.7.0/d3.min.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.js"></script>
    <!-- Below switching to tidy tree 0.5.1 as the dev broke 0.5.0 -->

    <!--script rel="stylesheet" type="text/javascript" href="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script-->
    
    <!--JQuery Beautiful Data Tables-->
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css">
    <script type="text/javascript" src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"></script>
    

    <!--Bootstrap 5 library elements-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    
    
    <!--toggle buttons by https://palcarazm.github.io/bootstrap5-toggle/ -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/css/bootstrap5-toggle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/js/bootstrap5-toggle.jquery.min.js"></script>

    <!-- Sweet Alerts 2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!--Colour distances calculation library at https://github.com/color-js/color.js-->
    <script src="https://colorjs.io/dist/color.global.js"></script>

    

    <script type="text/javascript">

        const __DEADBEEF__ = 0xDEADBEEF;
        const __DEADFOOD__ = 0xDEADF00D;
        //var test_newick = "(((B:1.000000,A:1.000000):3.0,C:4.000000):4.0,D:8.000000);"
        //var test_newick = "((BGIOSIFCE006902.1_ORYSA:0.652945[&&NHX:S=ORYSA],(At4g19560.1_ARATH:0.566484[&&NHX:S=ARATH],(At4g19600.1_ARATH:0.229647[&&NHX:S=ARATH],At5g45190.1_ARATH:0.149569[&&NHX:S=ARATH]):0.109796[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.283052[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.930921[&&NHX:S=Magnoliophyta:D=N:B=100],((((((((((((CCNK_HUMAN:0.001351[&&NHX:S=HUMAN],CCNK_F3_PANTR:0.001588[&&NHX:S=PANTR]):0.009317[&&NHX:S=Homo/Pan/Gorilla_group:D=N:B=100],CCNK_MACMU:0.01227[&&NHX:S=MACMU]):0.020339[&&NHX:S=Catarrhini:D=N:B=100],(CCNK_BOVIN:0.049478[&&NHX:S=BOVIN],CCNK_CANFA:0.076883[&&NHX:S=CANFA]):0.026972[&&NHX:S=Laurasiatheria:D=N:B=97]):0.01376[&&NHX:S=Eutheria:D=N:B=62],(Ccnk_MOUSE:0.018183[&&NHX:S=MOUSE],LOC500715_RAT:0.02728[&&NHX:S=RAT]):0.054247[&&NHX:S=Murinae:D=N:B=100]):0.087752[&&NHX:S=Eutheria:D=N:B=65],CCNK_MONDO:0.069457[&&NHX:S=MONDO]):0.053263[&&NHX:S=Theria:D=N:B=83],NP_001026380_CHICK:0.085022[&&NHX:S=CHICK]):0.059401[&&NHX:S=Amniota:D=N:B=80],CCNK_XENTR:0.175799[&&NHX:S=XENTR]):0.075577[&&NHX:S=Tetrapoda:D=N:B=97],((si_dkey-60a16_F2_BRARE:0.143195[&&NHX:S=BRARE],(CCNK_TETNG:0.142629[&&NHX:S=TETNG],CCNK_F2_GASAC:0.115749[&&NHX:S=GASAC]):0.130837[&&NHX:S=Percomorpha:D=N:B=100]):0.077038[&&NHX:S=Clupeocephala:D=N:B=95],ENSGACT00000017400_GASAC:0.40355[&&NHX:S=GASAC]):0.058401[&&NHX:S=Clupeocephala:SIS=33:D=Y:B=13]):0.233994[&&NHX:S=Euteleostomi:D=N:B=18],(ENSCINT00000017473_CIOIN:0[&&NHX:S=CIOIN],ENSCINT00000026852_CIOIN:0.002343[&&NHX:S=CIOIN]):0.481407[&&NHX:S=CIOIN:SIS=100:D=Y:B=100]):0.090892[&&NHX:S=Chordata:D=N:B=98],((CycK-RA_DROME:0.17719[&&NHX:S=DROME],dper_GLEANR_8777_caf1_DROPE:0.174477[&&NHX:S=DROPE]):0.199588[&&NHX:S=Sophophora:D=N:B=100],(AAEL013531-RA_AEDAE:0.214131[&&NHX:S=AEDAE],XP_317464_ANOGA:0.204436[&&NHX:S=ANOGA]):0.178396[&&NHX:S=Culicidae:D=N:B=100]):0.293157[&&NHX:S=Diptera:D=N:B=100]):0.104694[&&NHX:S=Coelomata:D=N:B=98],Smp_130980_SCHMA:0.624197[&&NHX:S=SCHMA]):0.041513[&&NHX:S=Bilateria:D=N:B=84],(WBGene00009650_CAEEL:0.186775[&&NHX:S=CAEEL],(CBG04574_CAEBR:0.21279[&&NHX:S=CAEBR],cr01.sctg48.wum.67.1_CAERE:0.192611[&&NHX:S=CAERE]):0.076335[&&NHX:S=Caenorhabditis:D=N:B=86]):1.18006[&&NHX:S=Caenorhabditis:D=N:B=86]):0.311276[&&NHX:S=Bilateria:D=N:B=84])[&&NHX:S=Eukaryota:D=N:B=0];"
        const TREE = __DEADBEEF__;
        // the '= __DEADFOOD__' is an expression to find and replace and inline tsv string e.g. 'head1\thead2\nv1\tv2\n's
        const DATA = __DEADFOOD__;
        const DEBUG = false;
        const TREE_OFFSET = 100;
        const TREE_LEFT_MARGIN_VIEWBOX_OFFSET = 30; //Space to accommodate near the root inner node labels
        var METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH = null; //before changing to full screen mode save the current size of the metadata table
        var LAST_METADATA_COLUMN_SELECTED = null;   //last metadata column selected for legend rendering. useful for subtree legend generation
        var NEWICK = null;
        var tree_root = null;
        var METADATA = null;
        var TABLE_HEADERS = null;
        var data_table = null;
        var query_table = null;
        var ORIGINAL_DATA = null;
        var ORIGINAL_VIEW_BOX = null;
        var ORIGINAL_WIDTH_SVG = 0;  
        var LAST_SCROLL_X = 0; // Store last scroll x-position making legend position updates smarter
        var LAST_SCROLL_Y = 0; // Store last scroll y-position  making legend position updates smarter
        var SHOW_BRANCH_LENGTHS = true;
        var SHOW_METADATA_IN_NAME = false;
        var LINE_THICKNESS = 2.0;  
        var TREE_VAL = "Dendrogram"; // sets default tree style to draw
        var PREVIOUS_UNCOLLAPSED_TREE_HEIGHT = 0; //previous tree hight uncollapsed useful when tree branches collapse
        /*
         As we are not passing the tree object into the d3 tree drawing functions
         we need this to be a global constant sadly. Unless we perform a larger refactor.
        */
        var TREE_ULTRAMETRIC_P = false; 

        var LABEL_SAFETY_FACTOR = 200
        var collapse_subtree = false; // can think of another way to signal state without our larger refactor 
        var focused_element = null; // Focused element to have its colour reset
        var RADIUS_INCREASED = false;
        var MENU_CREATED = false;
        const colour_legend = new Array;
        const default_color = "#999";
        const clicked_color = "blue";
        const ID_FIELD = 0;
        // Refactoring selected nodes to make it easier to update the legend and selected nodes on dom changes
        const right_mouse = 3;
        const center_mouse = 2;
        const left_mouse = 1;
        const CIRCLE_SIZE_SELECTED = 6;
        const INNER_NODE_SIZE = 4;
        const LEAF_NODE_SIZE = 6;
        var DECIMAL_PLACES = 1;
        const DISTANCE_LABEL_OFFSET = 5.2;
        
        var LABEL_TRUNCATE_SIZE = 50; // When a given text label exceed the length of this value it is truncated
        let ORIGINAL_CONTROL_PANEL_HEIGHT=null; //The original dimensions of the left control panel that are needed to bring it back to original size


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TREE FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // These are messy due to the way in which they were created, and there has not been time
        // to refactor them yet sadly.

        // ===== CHANGE: Font Size to Average Width Mapping =====
            // This table defines average character width multipliers for different font sizes in a typical sans-serif font (like Arial or Helvetica)
            // E.g. Each character averages 0.62 × 12px = 7.44px wide
            // We need to do approximate max label width calculation as DOM is not rendered at this stage preventing usage of bbox()
        const FONT_METRICS = {
                8:  0.52,  // avg width multiplier for 8px font
                9:  0.55,
                10: 0.58,
                11: 0.60,
                12: 0.62,  // default size
                14: 0.65,
                16: 0.68,
                18: 0.70
            };

        /**
        * Estimates the pixel width of text based on font size and average character width metrics.
        * Uses predefined font metrics for accurate estimation without DOM measurement.
        * 
        * @function estimateTextWidth
        * @param {string} text - The text string to measure
        * @param {number} fontSize - Font size in pixels (must match FONT_METRICS keys for best accuracy)
        * @returns {number} Estimated width in pixels
        * 
        **/
        function estimateTextWidth(text, fontSize) {
                const AVG_CHAR_WIDTH = FONT_METRICS[fontSize];
                return text.length * AVG_CHAR_WIDTH * fontSize;
        }
        
        
        function addDisplayDistance(d, rd){

            let next_rd = null;
            if(TREE_ULTRAMETRIC_P){
                // Collapsing currently does not work due to the subtracting at 
                // each step
                d.display_dist = rd - d.data.d
                next_rd = d.display_dist
            }else{
                d.display_dist = d.data.max_length     
                next_rd = d.data.max_length
            }

            if (d.children) {
                d.children.forEach(d => addDisplayDistance(d, next_rd))
            }
        }

        function maxLength(d) {
            return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
        }

        const addTreeDisplayDistance = (tree_root) => {
            tree_root.display_dist = tree_root.data.max_length
            if(TREE_ULTRAMETRIC_P){
                // Get the root to leaf length for display
                tree_root.display_dist = maxLength(tree_root)
            }

            tree_root.children.forEach(d => addDisplayDistance(tree_root, tree_root.display_dist))

        }

        function enableVerticalElementDrag(targetGroup) {
            let isDragging = false;
            let startY = 0;
            let initialTransformY = 0;
            let isSelected = false;

            // Make it focusable and style cursor
            targetGroup
                .attr("tabindex", 0)

            // Handle selection and mouse dragging
            targetGroup.on("mousedown", function (event) {
                event.stopPropagation(); // Prevent body from deselecting
                isSelected = true;
                targetGroup.node().focus(); // Give focus so keyboard works
                isDragging = true;
                startY = event.clientY;
                initialTransformY = getCurrentY();
                event.preventDefault();
            });

            // Deselect when clicking elsewhere
            d3.select("body").on("mousedown", function () {
                isSelected = false;
                targetGroup.node().blur(); // Remove focus Act as if the user clicked away from the cell.
            });

            // Keyboard interaction only when selected
            targetGroup.on("keydown", function (event) {
                if (!isSelected) return;
                const currentY = getCurrentY();
                const step = 5;
                if (event.key === "ArrowUp") {
                setTransform(currentY - step);
                event.preventDefault();
                } else if (event.key === "ArrowDown") {
                setTransform(currentY + step);
                event.preventDefault();
                }
            });

            // Global mouse movement tracking for dragging
            d3.select(window)
                .on("mousemove.scaleBar", function (event) {
                if (isDragging) {
                    const deltaY = event.clientY - startY;
                    setTransform(initialTransformY + deltaY);
                }
                })
                .on("mouseup.scaleBar", function () {
                isDragging = false;
                });

            // Helpers
            function getCurrentY() {
                const transform = targetGroup.attr("transform");
                const match = transform && transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                return match ? parseFloat(match[2]) : 0;
            }

            function setTransform(y) {
                targetGroup.attr("transform", `translate(0, ${y})`);
            }
        }
   


        function drawScale(svg, length, height, max_length, root){
            /**
             * Draws an interactive scale bar for phylogenetic tree visualizations with configurable ticks and labels.
             * Supports both ultrametric (time-based) and non-ultrametric (divergence-based) trees with automatic tick spacing.
             * Includes a draggable UI element with toggle control and dynamic label formatting.
             *
             * @function drawScale
             * @param {d3.Selection} svg - D3 selection of the SVG container where the scale will be rendered
             * @param {number} length - Pixel length of the scale bar (visual width)
             * @param {number} height - Vertical position from top of SVG (in pixels)
             * @param {number} max_length - Maximum tree distance in data units (e.g., substitutions/site)
             * @param {d3.HierarchyNode} root - D3 hierarchy node containing tree data with max_length property
             *   Should include a `data.max_length` field representing the starting cumulative distance from the root,
             *   which is used in non-ultrametric trees to adjust the scale bar labels.
             *
             * @returns {void}
             *
             * @example
             * // Assuming you have a D3 SVG selection and tree metadata:
             * drawScale(svg, 200, 30, 1.2, treeRootNode);
             *
             * @remarks
             * - Creates a draggable scale bar via mouse and keyboard arrow keys group via CSS class 'scale-bar'
             * - Implements smart tick spacing using human-friendly intervals (1, 2, 5, 10...)
             * - Handles both forward (root→tips) and reverse (tips→root) scaling directions for two tree types
             * - Minor ticks drawn at 1/10th intervals of major ticks
             * - Major ticks colored red and have numeric labels up to the DECIMAL_PLACES defaulting to 1
             
             * @notes
             * scale bar is slightly difficult to add, as the svg viewport dat only shows up AFTER rendering
             */
            
            const padding = { 
                top: -2,    // Gap above the scale bar text
            }
                    // --- Input Validation ---
            try {
                if (!svg || typeof svg.append !== 'function' || svg.empty()) {
                    throw new Error("Invalid 'svg' parameter: expected a D3 selection.");
                }
                if (typeof length !== 'number' || isNaN(length) || length <= 0) {
                    throw new Error("Invalid 'length' parameter: must be a positive number.");
                }
                if (typeof height !== 'number' || isNaN(height) || height < 0) {
                    throw new Error("Invalid 'height' parameter: must be a non-negative number.");
                }
                if (typeof max_length !== 'number' || isNaN(max_length) || max_length <= 0) {
                    throw new Error("Invalid 'max_length' parameter: must be a positive number.");
                }
                if (!root || typeof root !== 'object' || !root.data || typeof root.data.max_length !== 'number') {
                    throw new Error("Invalid 'root' parameter: must be an object with 'data.max_length' number.");
                }
            } catch (error) {
                console.error("drawScale() failed due to invalid input:", error.message);
                return; // Exit early to avoid rendering with bad input
            }
            const scaleBarGroup = svg.append("g")
                                     .attr("id", "scale-bar-group") //group all svg path elements under single group
                                    .attr("transform", `translate(0, ${padding.top})`);
            
            enableVerticalElementDrag(scaleBarGroup); //enables vertical drag of the scale bar

            let scale_bar_menu = `<div id="scale-bar-menu" class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn scalebar on/off">
                <small  class="flex-grow-1" for="scale_bar_toggle">Scale Bar</small>
                <input id="scale-bar-toggle" onchange="scale_bar_on_off(this)" id="scale_bar_toggle" checked type="checkbox" data-toggle="toggle" data-onstyle="primary" data-size="sm">
            </div>`

            $(scale_bar_menu).insertBefore("#legend-box")
            $("#scale-bar-toggle").bootstrapToggle()
            $("#scale-bar").css("visibility", "visible");

           let scale = `M 0 -${height} H ${length}` //defines the length of the scale object
           let stroke_width = 5
           let bar_opacity = 0.4
           const fontSize = 12; // Match your label font-size
           

           scaleBarGroup.append("path")
            .attr("d", scale)
            .attr("stroke-width", stroke_width)
            .attr("stroke-opacity", bar_opacity)
            .attr("stroke", "#000")
            .attr("fill-opacity", 1)
            .attr("class", "scale-bar")

            // Estimate maximum label width (using your font size 12px)
            const maxLabel = max_length.toFixed(DECIMAL_PLACES);
            const longestLabelWidth = estimateTextWidth(maxLabel, fontSize);
            
            
            // Update min spacing to prevent label overlap (130% of longest label)
            let minMajorTickSpacingPx = Math.max(longestLabelWidth, 25);// Minimum spacing between major ticks in pixels with 25 px as default min             
            let n_minor_divisions = 0, num_major_ticks = 0; 
            let factor_selected = 0;  
            let maxMajorTicks = Math.floor(length / minMajorTickSpacingPx);

            let niceSteps = [0.01, 0.02, 0.05, 0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 25, 50, 100, 200, 500, 1000]; // "Nice" human-friendly steps

            let step = 1;
            let full_steps = 0;
            let remainder = 0;
            let minor_per_step = 10;
            let minor_step = 0.1;
            let pixel_per_unit = length / max_length;
            for (let i = 0; i < niceSteps.length; i++) {
                let tickCount = Math.ceil(max_length / niceSteps[i]);
                let tickSpacingPx = length / tickCount;
                if (tickSpacingPx >= minMajorTickSpacingPx && tickCount <= maxMajorTicks) {
                    step = niceSteps[i];
                    minor_step = step / minor_per_step;
                    full_steps = Math.floor(max_length / step);
                    remainder = max_length - full_steps * step;
                    num_major_ticks = full_steps + 1; // last tick will be at full_steps * step
                    n_minor_divisions = full_steps * minor_per_step + Math.floor(remainder / minor_step);
                    factor_selected = 1 / step;
                    break;
                }
            }

            
            // Draw minor ticks going from left to right (-->) 
            let minor_ticks_coordinates_px = [];
            for (let i = 0; i <= n_minor_divisions; i++) {
                let value = i * minor_step;
                let px = value * pixel_per_unit;
                scaleBarGroup.append("path")
                    .attr("d", `M ${px} -${height - stroke_width} V -${height}`)
                    .attr("fill-opacity", 1)
                    .attr("stroke", "#000")
                    .attr("class", "scale-bar")
                    .attr("stroke-width", "1");
                minor_ticks_coordinates_px.push(px);
            }
                        
            
            
            /**
             * @remarks
             * Renders major tick marks and numeric labels along the scale bar
             *
             * - For **non-ultrametric trees** such as ML (max likelihood) and phylogenetic trees (`TREE_ULTRAMETRIC_P` is `false`):
             *   - tick marks and distances progress from left to right (→), representing
             *     cumulative evolutionary distance from the root to leaves rendered
             *     in red.
             *   - Uses `root.data.max_length` as a starting offset, which may be non-zero
             *     in ML trees or rooted trees inferred from input data (i.e. newick file).
             *   - Major tick text labels are generated at regular intervals (defined by `test_inc`) rendered above each major tick
             *
             * - For **ultrametric trees** (`TREE_ULTRAMETRIC_P` is `true`):
             *   - tick marks and labels progress from right to left (←), reflecting the cummulative
             *     distance/height from leaves to the root.
             *   - Major ticks coordinates are extracted from reversed minor tick coordinates,
             *     with every 10th tick selected.
             *   - Each tick is labeled with the corresponding tree distance, scaled
             *     by the selected factor to maintain appropriate precision.
             *
             * In both cases, red tick marks represent major divisions, and text labels
             * above them denote tree distance values based on `DECIMAL_PLACES` selected value defaulting to 1.
             */
            
            if(!TREE_ULTRAMETRIC_P){
                // From root to leaves (left to right)
                //phylogenetic tree showing cumulative distance from root to the leaf (-->)
                let distance_root_start = root.data.max_length || 0 //root node might start not at zero in ML phylo tree
                let major_ticks_coordinates_px = minor_ticks_coordinates_px.filter((c,index) => index % 10 === 0);
                
                for(let i=0; i <= full_steps; i+=1 ){
                    const px = major_ticks_coordinates_px[i];
                    let raw_dist = i * step + distance_root_start; //some trees might start from non-zero distance at root
                    let d = raw_dist === 0 ? "0" : raw_dist.toFixed(DECIMAL_PLACES);  //do not apply decimal points correction to 0

                    //major divisions
                    scaleBarGroup.append("path")
                    //.attr("d", `M ${i * increase_factor} -${height - stroke_width}  V -${height + stroke_width}`)
                    .attr("d", `M ${major_ticks_coordinates_px[i]} -${height - stroke_width} V -${height + stroke_width}`)
                    .attr("fill-opacity", 1)
                    .attr("stroke", "red")
                    .attr("class", "scale-bar")
                    .attr("stroke-width","3")
                    
                    //major divisions text
                    scaleBarGroup.append("text")
                    //.attr("dx", i * increase_factor)
                    .attr("dx",major_ticks_coordinates_px[i])
                    .attr("stroke", "#000")
                    .attr("fill", "#000")
                    .attr("stroke-width", 1)
                    .attr("fill-opacity", 1)
                    .attr("dy", -height - 5)
                    .text( d )
                    .attr("font-size", fontSize)
                    .attr("class", "scale-bar")
                }
            }else{
                //the tree is ultrametric showing a distance bar from leaf to the root that is from right to left (<--)
                let major_ticks_coordinates_px = minor_ticks_coordinates_px.reverse().filter((c,index) => index % 10 === 0);
                for(let i=0; i <= full_steps; i+=1){
                    let raw_dist = i * step;
                    let d = raw_dist === 0 ? "0" : raw_dist.toFixed(DECIMAL_PLACES); //do not apply decimal points correction to 0
                 
                    //add major ticks in RED
                    scaleBarGroup.append("path")
                    .attr("d", `M ${major_ticks_coordinates_px[i]} -${height - stroke_width} V -${height + stroke_width}`)
                    .attr("fill-opacity", 1)
                    .attr("stroke", "red")
                    .attr("class", "scale-bar")
                    .attr("stroke-width","2")
                   
                    //add major ticks text
                    scaleBarGroup.append("text")
                    .attr("dx", major_ticks_coordinates_px[i]) //length-(i*increase_factor))
                    .attr("stroke", "#000")
                    .attr("fill", "#000")
                    .attr("stroke-width", 1)
                    .attr("fill-opacity", 1)
                    .attr("dy", -height - 5)
                    .text( d )
                    .attr("font-size", fontSize)
                    .attr("class", "scale-bar")
                }

            }    

        }


        const cladeogram_chart = (data) => {
            // Made with lost of help from: https://observablehq.com/d/6c52fee38fb28b2f
                $("#branch_lengths_toggle").bootstrapToggle('off')
                SHOW_BRANCH_LENGTHS = false;
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width)-TREE_OFFSET+TREE_LEFT_MARGIN_VIEWBOX_OFFSET;
    
                //var width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30; // updated for viewing
                const marginLeft = 40;

                const inner_radius = width - LABEL_SAFETY_FACTOR;


                function maxLength(d) {
                    return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
                }

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
                
                
                const leaves_in_tree = root.leaves();
                const pixels_per_label = 15;
                
                const dx = 20;

                const dy = inner_radius / root.height;

                function setDistance(d, y0, k, dy) {
                    // From the tree of life code
                    d.distance = inner_radius - (d.height * dy)
                    if (d.children){
                        d.children.forEach(d => setDistance(d, y0, k, dy));
                    } 
                }

                setDistance(root, root.data.d = 0, (inner_radius / maxLength(root)), dy) // Third value is a scaling factor

                
                tree = d3.cluster()
                            .nodeSize([dx, dy])
                            .separation( (a, b) => { return 1;}) // Can pass in a custom function to alter distance between labels, 1 means all labels are spaced the same distance
                
                diagonal = (d) => {
                    // https://www.w3.org/TR/SVG/paths.html#PathElement for path movements meanings
                    // https://yqnn.github.io/svg-path-editor/ for planning paths
                    return `M${d.source.distance},${d.source.x} V${d.target.x} H${d.target.distance}`

                };
                
                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width) //makes sure all tree nodes are within view
                    .attr("class", "tree-svg")
                
                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}"); 


                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");


                function update(event, source) {
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                    const links = root.links();

                    // Compute the new tree layout...
                    tree(root);

                    let left = root;
                    let right = root;
                    
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });


                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition("tree-layout")
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [-TREE_LEFT_MARGIN_VIEWBOX_OFFSET, left.x - marginTop, 
                                            width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"))
                        .on("end", () => {
                            svg.dispatch("layout-complete");// This tells the rest of the app "The tree is done rendering!"
                        });

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        //.attr("transform", d => `translate(${d.distance},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(d.data.leaf){
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        }) 
                        .on("mousedown", (event, d) => {
                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);
                                                }
                                            }
                                        }
                                      updateLeafLabelsDisplay();
                                    }
                                });
                            }
                        });
                    
                    nodeEnter.append("circle")
                        .attr("r", d => !d.data.leaf ? INNER_NODE_SIZE : LEAF_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                        .attr("fill", d => !d.data.leaf ? "#555" : "#999")               
                        .attr("stroke-width", 10);
            
                    
                    // Add branch length to all inner nodes
                    nodeEnter.append("text")
                        .text((d) => {
                            if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                            }})
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        .attr("dx", (d) => { 
                            let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                            return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 14)
                        .attr("font-size", 12);
                    
                    nodeEnter.append("text")
                        // dx the 12 corresponds to a safety metric to add some space between nodes, no children, dx is 0 to align leaves to inner nodes
                        // Below two lines allow for inner nodes to show up
                        .attr("dx", d => !d.data.leaf ? 0 : inner_radius - d.distance + 12) 
                        .attr("dy", d => !d.data.leaf  ? -8 : 0) 
                        .attr("x", d => !d.data.leaf ? -10 : 6)
                        .attr("font-size", 12)
                        .attr("text-anchor", d => !d.data.leaf ? "end" : "start")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .text(d => d.data.meta ? d.data.name ? `${d.data.name} | ${d.data.meta}` : d.data.meta : d.data.name )
                        .clone(true).lower()
                        .attr("stroke", "white");
                    
                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.distance},${d.x})`) // aligns the text to the nodes
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)
                        .attr("d", diagonal);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", diagonal);

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", diagonal);

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
                }

            // Do the first update to the initial configuration of the tree — where a number of nodes
            // are open (arbitrarily selected as the root, plus nodes with 7 letters).
            root.x0 = dy / 2;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            });
            
            addTreeDisplayDistance(root)
            update(null, root);
            
            return svg.node();
        };

        /**
         * Renders a D3.js dendrogram chart based on the provided hierarchical data.
         * This function handles the layout, scaling, and rendering of the tree,
         * including node and link creation.
         *
         * @param {object} data - The hierarchical data object representing the tree structure.
         * This object is expected to be a PLAIN JavaScript object (not a D3 node object),
         * containing properties like 'name', 'length', 'max_length', 'meta', and 'children'.
         * @returns {SVGElement} The SVG DOM element containing the rendered dendrogram chart.
         */
        const dendrogram_chart = (data) => {
                
                // Made with lots of help from: https://observablehq.com/d/6c52fee38fb28b2f
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width)-TREE_OFFSET+TREE_LEFT_MARGIN_VIEWBOX_OFFSET;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30; // updated for viewing
                const marginLeft = 40;

                const inner_radius = width - LABEL_SAFETY_FACTOR;

                function setDistance(d, y0, k) {
                    // From the tree of life code
                    d.distance = (y0 += d.data.d) * k;
                    if (d.children) d.children.forEach(d => setDistance(d, y0, k));
                }

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));

                let max_length = maxLength(root)
                setDistance(root, root.data.d = 0, (inner_radius / max_length)) // Third value is a scaling factor

                const leaves_in_tree = root.leaves();
                const pixels_per_label = 15;
                const dx = 20;
                const root_node_height = dx * 0.5;
                const dy = inner_radius / root.height;

                // Test Scale drawing
                tree = d3.cluster()
                            .nodeSize([dx, dy])
                            .separation( (a, b) => { return 1;}) // Can pass in a custom function to alter distance between labels, 1 means all labels are spaced the same distance


                diagonal = (d) => {
                    // https://www.w3.org/TR/SVG/paths.html#PathElement for path movements meanings
                    return `M${d.source.distance},${d.source.x} L${d.source.distance},${d.target.x} L${d.target.distance},${d.target.x}`
                };

                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width) //makes sure all tree nodes are within view
                    .attr("class", "tree-svg")

                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");    
                
                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");
                
                function showLinkExtension(d, show=true) {
                        const dest = show ? inner_radius : d.target.distance;
                        const path = d3.path();
                        path.moveTo(d.target.distance, d.target.x);
                        path.lineTo(dest, d.target.x);
                        return path.toString();
                }

                let below_root = 0; 
                function update(event, source) {
                    console.debug("Performing tree update")
                    // Recalculate tree lengths on collapse
                    let max_length = maxLength(root)
                    setDistance(root, root.data.d = 0, (inner_radius / max_length)) // Third value is a scaling factor


                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                    const links = root.links();

                    // Compute the new tree layout.
                    // Converting tree to cluster may solve our conundrum...
                    tree(root);
                    
                    svg.selectAll(".extension-node-links").remove();
                    
                    
                    const linkExtension = svg.append("g") // Would probably save rendering if this was tied to the "entered nodes"
                            .attr("class", "extension-node-links")
                            .attr("fill", "none")
                            .attr("stroke", "#000")
                            .attr("stroke-opacity", 0.5)
                            .attr("stroke-dasharray", "4")
                            .selectAll("path")
                            .data(root.links().filter(d => d.target.data.leaf ))
                            .join("path")
                            .each(function(d) { d.target.linkExtensionNode = this; })
                            .attr("d", (d) => showLinkExtension(d, true)); // Shows lines to link
                    
                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });
                    
                    
                    //calculate a tree height
                    const newTreeHeight = right.x - left.x + marginTop + marginBottom
                    if (newTreeHeight > PREVIOUS_UNCOLLAPSED_TREE_HEIGHT ){
                        PREVIOUS_UNCOLLAPSED_TREE_HEIGHT = newTreeHeight
                    }

                    function updateScaleBarPosition(newTreeHeight) {
                        d3.select("#scale-bar-group")
                            .transition()
                            .duration(750) // Smooth transition
                            .attr("transform", `translate(0, ${newTreeHeight})`);
                    }
                    updateScaleBarPosition(PREVIOUS_UNCOLLAPSED_TREE_HEIGHT - newTreeHeight)



                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition("tree-layout")
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [-TREE_LEFT_MARGIN_VIEWBOX_OFFSET, left.x - marginTop, 
                                            width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"))
                        .on("end", () => {
                            svg.dispatch("layout-complete");// This tells the rest of the app "The tree is done rendering!"
                        });

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(d.data.leaf){
                                // count nodes below the root to set offset height for the scale
                                if(d.x > -root_node_height){ 
                                    below_root++
                                }
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        })
                        .on("mousedown", (event, d) => {

                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants();
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);

                                                }
                                            }
                                        }
                                      updateLeafLabelsDisplay();
                                    }
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", d => !d.data.leaf ? INNER_NODE_SIZE : LEAF_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                        .attr("fill", d => !d.data.leaf ? "#555" : "#999")
                        .attr("stroke-width", 10);                    

                    // Add branch length to all inner nodes
                    nodeEnter.append("text")
                        .text((d) => {
                                if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                    return Number((d.display_dist).toFixed(DECIMAL_PLACES));
                                }
                            })
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        .attr("dx", (d) => { 
                                let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                                return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 14)
                        .attr("font-size", 12);

                       
                    nodeEnter.append("text")
                        // dx the 12 corresponds to a safety metric to add some space between nodes, no children, dx is 0 to align leaves to inner nodes
                        // Below two lines allow for inner nodes to show up
                        .attr("dx", d => !d.data.leaf ? 0 : inner_radius - d.distance + 12) 
                        .attr("dy", d => !d.data.leaf ? -8 : 0) 
                        .attr("x", d => !d.data.leaf ? -10 : 6)
                        .attr("font-size", 12)
                        .attr("text-anchor", d => !d.data.leaf ? "end" : "start")
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .text(d => {
                            // If meta is a string or name is defined for the node
                            return d.data.meta ? d.data.name ? `${d.data.name} | ${d.data.meta}` : d.data.meta : d.data.name
                            
                        })
                        .clone(true).lower()
                        .attr("stroke", "white");
                    
                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.distance},${d.x})`) // aligns the text to the nodes
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)
                        .attr("d", diagonal);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", diagonal);

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", diagonal);

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
            }

            // Do the first update to the initial configuration of the tree — where a number of nodes
            // are open (arbitrarily selected as the root, plus nodes with 7 letters).
            root.x0 = dy / 2;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            });

            addTreeDisplayDistance(root)
            update(null, root);
            
            //! This math is not working out for all general cases :(
            /* 
                Formula for getting the scale bar at the top is
                
                (dx * number of leaves in the tree) - (number of leaves below root * dx)
            */
            if(below_root > 1){
                // Just one value is likely the root, and it needs to be ignored in its offset
                below_root--
            }
            
            if(!TREE_ULTRAMETRIC_P){
                max_length = maxLength(root)
            }else{
                max_length = root.display_dist
            }
            //let display_width = parseInt(ele_style.width) - label_safety_factor
            //draw a scale bar
            
            drawScale(gNode, inner_radius, (dx * leaves_in_tree.length) - (below_root*dx)-5, max_length, root)

            //svg.on("layout-complete", () => {
            //    console.debug("Layout rendering is complete now and can update the leaf nodes")
            //    updateLeafLabelsDisplay(); 
            //});

            return svg.node();
        };


        const dendrogram_circle = (data) => {
            // Made with lots of help from: https://observablehq.com/d/6c52fee38fb28b2f
            var ele = document.getElementById("TreeData");
            var ele_style = window.getComputedStyle(ele);
            const root = d3.hierarchy(data);
            
            const maxLabelCharCount = d3.max(root.leaves(), d => {return d.data.name.length;});
            const labelBuffer = maxLabelCharCount * 12; //12px per character 

            const width = parseInt(ele_style.width)-TREE_OFFSET + labelBuffer;
            const height = width; //this plot will have square dimensions with circle inside
            const outerRadius = width / 2; 
            const innerRadius = outerRadius;
            const decimal_places = 4;
            const sc_to_radians = Math.PI / 180;

           
            root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
            addTreeDisplayDistance(root)
            
            const dx = 20; 
            const dy = outerRadius;

           
        
            function linkStep(startAngle, startRadius, endAngle, endRadius) {
                const c0 = Math.cos(startAngle = (startAngle - 90) / 180 * Math.PI);
                const s0 = Math.sin(startAngle);
                const c1 = Math.cos(endAngle = (endAngle - 90) / 180 * Math.PI); 
                const s1 = Math.sin(endAngle); 
                
                return "M" + startRadius * c0 + "," + startRadius * s0
                    + (endAngle === startAngle ? "" : "A" + startRadius + "," + startRadius + " 0 0 " + (endAngle > startAngle ? 1 : 0) + " " + startRadius * c1 + "," + startRadius * s1)
                    + " L" + endRadius * c1 + "," + endRadius * s1;
            }
            
            function setRadius(d, y0, k) {
                
                d.radius = (y0 += d.data.d) * k;
                if (d.children) d.children.forEach(d => setRadius(d, y0, k));
            }

            function linkVariable(d) {
                return linkStep(d.source.x, d.source.radius, d.target.x, d.target.radius);
            }

            function maxLength(d) {
                return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
            }

            function linkConstant(d) {
                return linkStep(d.source.x, d.source.y, d.target.x, d.target.y);
            }

            function linkExtensionVariable(d) {
                return linkStep(d.target.x, d.target.radius, d.target.x, innerRadius);
            }

            function linkExtensionConstant(d) {
                return linkStep(d.target.x, d.target.y, d.target.x, innerRadius);
            }

            tree = d3.cluster()
                .size([360, innerRadius])
                .separation((a, b) => 1);

            const svg = d3.create("svg")
                .attr("id", "TreeSVG")
                .attr("viewBox", [0, 0, width, height])
                .attr("class", "tree-svg")
            
            svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");  

            const gNode = svg.append("g")
                .attr("cursor", "pointer")
                .attr("pointer-events", "all")
                .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
            
            const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS)
                    .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
            
            root.data.d = 0
            const max_len = innerRadius / maxLength(root)
            setRadius(root, root.data.d, max_len);

            function translate_points(d){

                let x = Math.cos((d.x - 90) * sc_to_radians) * d.radius
                let y = Math.sin((d.x - 90) * sc_to_radians) * d.radius;
                let output = `rotate(${d.x - 90}) translate(${d.radius},0)`
                return output
            }

            function translate_text(d){
                let new_rad = innerRadius - d.radius + 6
                if(!d.data.leaf){
                    new_rad = d.radius
                }
                

                
                let x = Math.cos((d.x - 90) * sc_to_radians) * new_rad;
                let y = Math.sin((d.x - 90) * sc_to_radians) * new_rad;

                let rot_val = d.x - 90;
                if(x < 0){
                    rot_val = d.x + 90;
                }
                d.x0 = x;
                d.y0 = y;
                let output = `translate(${x}, ${y}) rotate(${rot_val})`
                return output
            }
            
            
            function update(event, source){

                const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                const links = root.links();
                tree(root)

                svg.selectAll(".extension-node-links").remove();

                const linkExtension = svg.append("g")
                    .attr("class", "extension-node-links")
                    .attr("fill", "none")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.25)
                    .attr("stroke-dasharray", "4")
                    .selectAll("path")
                    .data(root.links().filter(d => d.target.data.leaf ))
                    .join("path")
                    .each(function(d) { d.target.linkExtensionNode = this; })
                    //.attr("d", linkExtensionConstant); // linkExtension constant can be passed in to align all branches to labels
                    .attr("d", (d) => linkExtensionVariable(d))
                    // Added to move points over
                    .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
                
                let left = root;
                let right = root;
                root.eachBefore(node => {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                });

                ORIGINAL_WIDTH_SVG=width
                const transition = svg.transition("tree-layout")
                    .duration(duration)
                    .attr("height", height)
                    .attr("viewBox", [0, 0, width, height])
                    .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"))
                    .on("end", () => {
                            svg.dispatch("layout-complete");// This tells the rest of the app "The tree is done rendering!"
                        });

                const node = gNode.selectAll("g:not(#scale-bar-group)")
                    .data(nodes, d => d.id);

                const nodeEnter = node.enter().append("g")
                    .attr("transform", translate_points)
                    // Transform statement below can be used to re-orient leaves at the cost of mis-aligning them on collapse
                    //.attr("transform", d => `rotate(${d.x - 90}) translate(${d.radius},0)${d.x < 180 ? "" : " rotate(180)"}`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .attr("id", (d) => {
                        if(d.data.name){
                            return d.data.name;
                        }
                    })
                    .attr("class", (d) => {
                        if(d.data.leaf){
                            return "tree-node leaf-node";
                        }
                        return "tree-node inner-node";
                    })
                    .on("mousedown", (event, d) => {

                        d.children = d.children ? null : d._children;
                        if(event.which == left_mouse){
                            NodeDropDownMenu(event, d, () => {
                                let updated_p = false;
                                updated_p = update(event, d);
                                if(updated_p){
                                    let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                    let uncollapsed_descendants_length = 1;
                                    // The length of the uncollapsed descendants is greater than one on uncollapse
                                    if(descendants.length > uncollapsed_descendants_length){
                                        for(const item of descendants){
                                            let name = item.data.name;
                                            if(name !== "" && SelectedNodes.nodes.has(name)){
                                                SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                SelectedNodes.setSelectedColours(text, circle);
                                            }
                                        }
                                    }
                                  updateLeafLabelsDisplay();
                                }
                            });
                        }
                });

                nodeEnter.append("circle")
                    .attr("r", d => d.data.leaf ? LEAF_NODE_SIZE : INNER_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                    .attr("fill", d => d.data.leaf ? "#999" : "#555")
                    .attr("stroke-width", 10);

                nodeEnter.append("text")
                    .text((d) => {
                        if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                            return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                        }})
                    .attr("class", "branch-length")
                    .style("visibility", () => {
                        if(!SHOW_BRANCH_LENGTHS){
                            return "hidden"
                        }else{
                            return "visible"
                        }
                    })
                    .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        //.attr("position", "relative")
                    .attr("dx", (d) => { 
                        let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                        return `${-val.length + 1}pt`;
                    })
                    .attr("transform", (d) => {
                        return ""
                    })
                    .attr("dy", 14)
                    .attr("font-size", "12");
                
                nodeEnter.append("text")
                    .attr("dy", d => !d.data.leaf ? -8 : 0) // dx being in a different cord system seems to be causing issues...
                    .attr("dx", (d) => {
                        let hyp = 0 
                        if(d.data.leaf){
                            hyp = innerRadius - d.radius + 6;
                        }else{
                            hyp = d.data.d - 10;
                        }
                        return hyp}) // labels are not bein moved to the correct pos when redrawn
                    .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                    .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                    .text(d => d.data.meta ? d.data.name ? `${d.data.name} | ${d.data.meta}` : d.data.meta : d.data.name )
                    .clone(true).lower()
                    .attr("font-size", "12")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke", "white");
                    

                // Getting spontatnous errors in redraw
                // get new position
                const nodeUpdate = node.merge(nodeEnter)
                    .transition(transition)
                    .attr("transform", translate_points) // aligns the text to the nodes
                    .attr("fill-opacity", 1)
                    .attr("stroke-opacity", 1);
                

                const nodeExit = node.exit().transition(transition).remove()
                    .attr("transform", translate_points) // aligns the text to the nodes
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0);
                
                // Update the links…
                const link = gLink.selectAll("path")
                    .data(links, d => d.target.id)
                    .attr("d", linkVariable);
                
                const linkEnter = link.enter().append("path")
                                    .attr("d", linkVariable);

                link.merge(linkEnter).transition(transition)
                        .attr("d", linkVariable);

                // Transition exiting nodes to the parent's new position.
                // TODO see if transition can be added it makes the whole flow smoother
                link.exit().remove(); // Removing the transition got rid of path errors

                // Stash the old positions for transition.
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
                return true;
            }
            
            root.x0 = root.x
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
            });

            
            addTreeDisplayDistance(root)
            update(null, root);

            
            return svg.node();
        };

        const tidytree_chart = (data) => {
                // Specify the charts’ dimensions. The height is variable, depending on the layout.

                $("#branch_lengths_toggle").bootstrapToggle('off')
                SHOW_BRANCH_LENGTHS = false;
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width)-TREE_OFFSET;
    

                
                //const width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30;
                const marginLeft = 40;

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
                const dx = 20;
                const dy = (width - marginRight - marginLeft) / (1 + root.height);

                // Define the tree layout and the shape for links.
                tree = d3.tree().nodeSize([dx, dy]);
                diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);
                
                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width + 20) //makes sure all tree nodes are within view
                    .attr("height", dx)
                    .attr("class", "tree-svg")
                
                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");   

                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");
                

                function update(event, source) {
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse();
                    const links = root.links();

                    // Compute the new tree layout.
                    // Converting tree to cluster may solve our conundrum...
                    tree(root);

                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });


                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition("tree-layout")
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [0, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"))
                        .on("end", () => {
                            svg.dispatch("layout-complete");// This event tells the rest of the app "The tree is done rendering!"
                        });

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(!d.children){
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        })
                        .on("mousedown", (event, d) => {
                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);

                                                }
                                            }
                                        }
                                        updateLeafLabelsDisplay();
                                    }
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", d => d.data.leaf ? LEAF_NODE_SIZE : INNER_NODE_SIZE)
                        .attr("fill", d => d.data.leaf ? "#555" : "#999")
                        .attr("stroke-width", 10);
        
                    nodeEnter.append("text") // TODO can do this with if statement and recurse over them all may be a bit slower but more mem friednly
                        .text((d) => {
                            if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                            }})
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        //.attr("position", "relative")
                        .attr("dx", (d) => { 
                            let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                            return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 18)
                        .attr("font-size", "12");

                       
                    nodeEnter.append("text")
                        .attr("dy", d => !d.data.leaf ? -6 : 0) 
                        .attr("x", d => !d.data.leaf ? -6 : 6)
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .text(d => d.data.meta ? d.data.name ? `${d.data.name} | ${d.data.meta}` : d.data.meta : d.data.name )
                        .clone(true).lower()
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-width", 3)
                        .attr("stroke", "white")
                        .attr("font-size", "12");
                    

                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", d => {
                                            const o = {x: source.x0, y: source.y0};
                                            return diagonal({source: o, target: o});
                                        });

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", d => {
                            const o = {x: source.x, y: source.y};
                            return diagonal({source: o, target: o});
                        });

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
                }

                // Do the first update to the initial configuration of the tree — where a number of nodes
                // are open (arbitrarily selected as the root, plus nodes with 7 letters).
                root.x0 = dy / 2;
                root.y0 = 0;
                root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                });
                
                addTreeDisplayDistance(root)
                update(null, root);
                
                return svg.node();

        }

        const RADIAL_DENDROGRAM = "Radial Dendrogram"
        const TREE_SWITCH = new Map([
            ["Dendrogram", dendrogram_chart], 
            ["TidyTree", tidytree_chart], 
            [RADIAL_DENDROGRAM, dendrogram_circle], 
            ["Cladeogram", cladeogram_chart]]); // key value pairs map to switch between tree views


        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ End of tree definitions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        // Class for selected nodes
        class SelectedNodes {
            static nodes = new Map();
            static #circle_pos = 1;
            static #name_pos = 3;
            static #circle_size_selected = LEAF_NODE_SIZE * 1.5;
            static #circle_size_default = LEAF_NODE_SIZE;
            static #default_color = "#999";
            static #clicked_color = "blue";
            static #svg_parent = "g";
            static selection_id = "#SelectedNodes";

            static getDefaultColour(){
                return SelectedNodes.#default_color;
            }

            static getSelectedColour(){
                return SelectedNodes.#clicked_color
            }

            static getCirclePos(){
                return SelectedNodes.#circle_pos;
            }

            static getNamePos(){
                return SelectedNodes.#circle_pos;
            }

            static clearNodes(){
                SelectedNodes.nodes.clear();
            }

            static setSelectedColours(text, circle){
                text.style.fontWeight = "bold";
                text.style.fill = "black";
                if(!circle.dataset.oldfill && circle.style.fill != SelectedNodes.#default_color){
                    circle.dataset.oldfill = circle.style.fill
                }
                circle.style.fill = SelectedNodes.#clicked_color;
                circle.setAttribute("r", SelectedNodes.#circle_size_selected);
            }

            static deSelectedColours(text, circle){
                text.style.fontWeight = "normal";
                text.style.fill = "black";
                if(circle.dataset.oldfill){
                    circle.style.fill = circle.dataset.oldfill;
                    if(circle.dataset.oldfill === SelectedNodes.#default_color){
                        delete circle.dataset.oldfill
                    }
                    
                }else{
                    circle.style.fill = SelectedNodes.#default_color
                }
                circle.setAttribute("r", SelectedNodes.#circle_size_default);

            }

            static getNodeData(element){
                let child_nodes = element.childNodes;
                let circle = child_nodes[SelectedNodes.#circle_pos];
                let text = child_nodes[SelectedNodes.#name_pos];
                return [element, circle, text]; // element is g tag
            }

            static addNodes(element) {    
            /* Function to update the set of nodes, going forward each node should probably contain the element by ID and the html element
            
            This class is also being refactored as it should never get a none leaf-node

            param element: a html "g" element to update the colour of
            */        
                let [parent, circle, text] = SelectedNodes.getNodeData(element.closest(SelectedNodes.#svg_parent));
                //SelectedNodes.nodes is a map where each key is sample_id
                if(!SelectedNodes.nodes.has(parent.id)){
                    //ensures that <g> node id is used instead of leaf node text as it is more reliable if node text label is changed
                    //  {'SRR3736595' => g#SRR3736595.tree-node.leaf-node, 'SRR3736593' => g#SRR3736593.tree-node.leaf-node}
                    SelectedNodes.nodes.set(parent.id, parent); 
                    SelectedNodes.setSelectedColours(text, circle);
                }else{
                    console.debug(`${parent.id} key already exists in SelectedNodes.nodes map.`)
                }    
                
            }

            static unselectNode(element){
                // Function tied to an on click event removing it from the map, legend and de-colouring it
                let elm = element.closest(SelectedNodes.#svg_parent)
                let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                SelectedNodes.deSelectedColours(text, circle);
                let dropped = SelectedNodes.nodes.delete(elm.id)
                console.debug("Dropping values:", text.textContent, dropped);
                
            }

            static deselectNodes(){
                for(const n of SelectedNodes.nodes){
                    SelectedNodes.unselectNode(n[SelectedNodes.#circle_pos]);
                }
                SelectedNodes.emptyNodeSelections();
            }

            static emptyNodeSelections(){
                $(SelectedNodes.selection_id).empty();
            }

            static drawSelectedNodes(){
                // Redraw the menu of selected nodes
                // and re-colour selected ones
                $(SelectedNodes.selection_id).empty().append(() => {
                    let attributes = new Array;
                    for(const [, nodeElement] of SelectedNodes.nodes.entries()){
                        attributes.push(`<div class="d-flex border-bottom align-items-center selected-node">
                        <div onclick="scroll_into_view_treenode('${nodeElement.id}')" class="flex-grow-1">${nodeElement.id}</div>
                        <div>
                            <button onclick="remove_selected_node(this.dataset.nodeId)" data-node-id="${nodeElement.id}" 
                            class="btn btn-danger m-1 btn-sm">x</button>
                        </div>
                        </div>\n`);
                        
                    }
                    
                    return `${attributes.join("")}`;
                });
            }
        }


        /** Code for parsing a newick tree to be used by D3
         * The code is taken from Knhx.js written by Heng Li
        */
        function kn_new_node() {
            // Heng li code to add node
            //return {parent:null, children:[], name:"", meta:"", d:-1.0, hl:false, hidden:false, leaf:false};
            return {parent:null, children:[], name:"", max_length: 0.0, meta:"", d:0.0, leaf:false};
        }

        function kn_add_node(str, l, tree, x, leaf) // private method
        {
            // Heng Li code to add nodes to a tree
            var r, beg, end = 0, z;
            z = kn_new_node();
            z.leaf = leaf;
            for (i = l, beg = l; i < str.length && str.charAt(i) != ',' && str.charAt(i) != ')'; ++i) {
                var c = str.charAt(i);
                if (c == '[') {
                    var meta_beg = i;
                    if (end == 0) end = i;
                    do ++i; while (i < str.length && str.charAt(i) != ']');
                    if (i == str.length) {
                        tree.error |= 4;
                        break;
                    }
                    z.meta = str.substr(meta_beg, i - meta_beg + 1).replace('[', '').replace(']', ''); //remove square bracket from metadata  e.g.(A:0.1,B:0.2)[metadata]C:0.3; based on NHX (New Hampshire Extended) format
                } else if (c == ':') {
                    if (end == 0) end = i;
                    for (var j = ++i; i < str.length; ++i) {
                        var cc = str.charAt(i);
                        if ((cc < '0' || cc > '9') && cc != 'e' && cc != 'E' && cc != '+' && cc != '-' && cc != '.')
                            break;
                    }
                    // Distance added here
                    z.d = parseFloat(str.substr(j, i - j));
                    --i;
                } else if (c < '!' && c > '~' && end == 0) end = i;
            }
            if (end == 0) end = i;
            if (end > beg) z.name = str.substr(beg, end - beg);
            tree.node.push(z);
            return i;
        }
    
        function kn_parse(str)
            {
                // Heng li Newick parsing code
            var stack = new Array();
            var tree = new Object();
            tree.error = tree.n_tips = 0;
            tree.node = new Array();
            for (var l = 0; l < str.length;) {
                while (l < str.length && (str.charAt(l) < '!' || str.charAt(l) > '~')) ++l;
                    if (l == str.length) break;
                    var c = str.charAt(l);
                    if (c == ',') ++l;
                    else if (c == '(') {
                        stack.push(-1); ++l;
                    } else if (c == ')') {
                        var x, m, i;
                        x = tree.node.length;
                        for (i = stack.length - 1; i >= 0; --i)
                            if (stack[i] < 0) break;
                        if (i < 0) {
                            tree.error |= 1; break;
                        }
                        m = stack.length - 1 - i;
                        l = kn_add_node(str, l + 1, tree, m, false);
                        for (i = stack.length - 1, m = m - 1; m >= 0; --m, --i) {
                            tree.node[x].children[m] = tree.node[stack[i]];
                            tree.node[stack[i]].parent = tree.node[x];
                        }
                        stack.length = i;
                        stack.push(x);
                    } else {
                        ++tree.n_tips;
                        stack.push(tree.node.length);
                        l = kn_add_node(str, l, tree, 0, true);
                    }
            }
            if (stack.length > 1) tree.error |= 2;
            tree.root = tree.node[tree.node.length - 1];
            TREE_ULTRAMETRIC_P = isUltrametric(tree)
            return tree;
        }


        function isUltrametric(tree){
            let stack = new Array();
            let distances = new Set();
            tree.root.max_length = tree.root.d
            stack.push(tree.root)
            while(stack.length > 0){
                let temp = stack.pop()
                if(temp.leaf){
                    // Round the max length, as floating point errors will make numbers
                    // appear sligthly different
                    // The max length is not added again, as the child distance is
                    // added in the else block below
                    distances.add(temp.max_length.toFixed(2))
                }else{
                        temp.children.forEach( (child) => {
                            child.max_length = temp.max_length + child.d
                            stack.push(child)
                        })
                }
            }
            if(distances.size === 1){
                return true
            }
            return false
        }


        //~~~~~~~~~ End of Heng Li's Code


        let CreateMenuItem = (node_type, text, evt_list_func, on_click) => {
            
            let node = document.createElement(node_type);
            
            if(node_type !== "h4"){ // Not liking the way this is formatted
                node.style.cursor = "default";
            }
            node.style.margin = "2px";
            //node.innerHTML = text;
            node.textContent = text;
            if(evt_list_func !== undefined){
                evt_list_func(node);
            }
            if(on_click !== undefined){
                node.onclick = on_click;
            }
            return node;
        }

        let ColourMouseOver = (node) => {
            // Set attributes for colouring of values
            node.classList.add("dropdown-item");
        };

        let AppendToParent = (parent, ...nodes) => {
            nodes.forEach(arg => parent.appendChild(arg));
        };

        let CreateDropDownDiv = (event) => {
            let offset_menu = 0;
            let leaveTimeout //defines menu timeout logic that can be cancelled
            // Temporarily increase node size on collection
            let circle = event.target.parentNode.getElementsByTagName("circle")[0];
            let rad_size = circle.getAttribute("r");
            let increased_size = rad_size * 5;
            if(!RADIUS_INCREASED && MENU_CREATED){
                circle.setAttribute("r", increased_size);
                RADIUS_INCREASED = true;
            }
            
            let drop_down_menu = document.createElement("div");

            drop_down_menu.classList.add("dropdown")
            drop_down_menu.style.position = "fixed";
            
          
            document.body.appendChild(drop_down_menu); // Attach to measure dimensions
          
            // Now position at the center of the context menu after the left mouse click
            drop_down_menu.style.left = `${event.pageX - 1}px`;
            drop_down_menu.style.top = `${event.pageY - 69}px`;
         
            //drop_down_menu.style.left = event.pageX+'px';
            //drop_down_menu.style.top = event.pageY+'px';
            drop_down_menu.style.borderStyle = "solid";
            drop_down_menu.style.borderWidth = "2px";
            drop_down_menu.style.borderRadius = "10pt"
            drop_down_menu.style.backgroundColor = "rgba(250, 252, 249, 0.9)" /* need to specify transparency only with rgba and not hex "#FAFCF9";*/
            drop_down_menu.setAttribute("id", "PopDownMenu");

            // Add event listeners to undo changes when leaving
            // When user clicks on the menu itself it will be deleted
            drop_down_menu.addEventListener("click", (event) => {
                drop_down_menu.remove();
                circle.setAttribute("r", rad_size);
                RADIUS_INCREASED = false;
                MENU_CREATED = false;
            });

            //remove circle enlarged
            drop_down_menu.addEventListener("mouseleave", (event) => {
                drop_down_menu.classList.add("fade-out-dropdown-menu"); // Optional: fade animation
                
                leaveTimeout = setTimeout(() => {
                    drop_down_menu.remove();
                    circle.setAttribute("r", rad_size);
                    RADIUS_INCREASED = false;
                    MENU_CREATED = false;
                }, 1000); // Matches the CSS transition duration
            });

            // If user moves the mouse back in, cancel the dropdown menu removal
            drop_down_menu.addEventListener("mouseenter", (event) => {
                clearTimeout(leaveTimeout);
                drop_down_menu.classList.remove("fade-out-dropdown-menu");
            });

            //detects that mouse moved outside the menu and now is over the tree and never entered menu
            /*
            document.getElementById("TreeSVG").addEventListener("mouseover", (event) => {
                drop_down_menu.remove();
                circle.setAttribute("r", rad_size);
                RADIUS_INCREASED = false;
                MENU_CREATED = false;
            })*/
            

            return drop_down_menu;
        }

        let NodeDropDownMenu = (event, data, func) => {
            // Rendering dropdown menu on click, it may be better to render a hidden menu for each node in a div
            // This would clutter the dom however
            
            if(event.target.parentNode.classList.contains("inner-node")){
                if(!MENU_CREATED){
                    MENU_CREATED = true;
                    let drop_down_menu = CreateDropDownDiv(event);
                    let title = CreateMenuItem("h4", "Node Options");


                    let collapse_tree = CreateMenuItem("p", "Collapse/Un-collapse branch", ColourMouseOver, func);                    

                    // TODO need to remove selected nodes when drawing subtree
                    let create_subtree = CreateMenuItem("p", "Display Sub-tree", ColourMouseOver, () => {
                        CustomSubTree(event, data);
                    });

                    let select_child_nodes = CreateMenuItem("p", "Select all Children", ColourMouseOver, () => {
                        SelectChildren(event, data);
                    });

                    AppendToParent(drop_down_menu, title, collapse_tree, create_subtree, select_child_nodes);            
                    let tree_element = document.getElementById("TreeData");
                    tree_element.append(drop_down_menu)
                }
            }else{
                LeafNode(event, data);
                SelectedNodes.drawSelectedNodes();
            }
        };

        const countNodes = (node) => {
            if (!node) {
                return 0;
            }
            let count = 1; // Count the current node
            if (node.children && Array.isArray(node.children)) {
                for (const child of node.children) {
                    count += countNodes(child); // Recursively add counts from children
                }
            }
            return count;
        };


        // Create a subtree from the inner node selected in a tree
        let CustomSubTree = (event, data) => {
            console.debug("Subtree is being rendered")
            const zoomSlider = document.querySelector('#zoom_slider');
            const zoomValueLabel = document.querySelector('#zoom_slider_value');
            zoomSlider.value = 1;
            zoomValueLabel.textContent = "1";

            const isLegendActive = !$('#colour-legend').hasClass('d-none');
            console.debug("Legend is active:", isLegendActive);
            $("#legend_toggle").bootstrapToggle('off')
            SelectedNodes.drawSelectedNodes();
            $('#colour-legend').empty()
            $('#colour-legend').addClass('d-none')
            $('#TreeSVG').remove()
            $("#scale-bar-menu").remove()
        

            if(data !== null){
                // Make copy of head node as data will be overwritten
                let copy_head_node=structuredClone(data.data)
                const totalNodes = countNodes(copy_head_node)
                
                console.debug(`New head node of the tree with ${totalNodes} nodes at distance ${copy_head_node.max_length} and ultrametric=${TREE_ULTRAMETRIC_P}`);
                //if a tree is non-ultrametric then create a subtree with subtracted distances from the head node selected as root now
               
                if (!TREE_ULTRAMETRIC_P){
                    const distanceToSubtract = copy_head_node.max_length;
                    const subtractDistance = (node, amount) => {
                    if (node.max_length !== undefined && node.max_length !== null) {
                        // Ensure the length does not go below zero after subtraction.
                        node.max_length = Math.max(0, node.max_length - amount);
                    }
                    // Recursively apply to children if they exist
                    if (node.children) {
                        node.children.forEach(child => subtractDistance(child, amount));
                    }
                };

                    // Apply the annotated distance subtraction to the copied head node and all its descendants.
                    subtractDistance(copy_head_node, distanceToSubtract);
                }
                console.debug(`Head node after subtraction ${copy_head_node.max_length}`);

                console.debug(copy_head_node)
                //RENDER tree based on the selected layout function
                let svg_chart = TREE_SWITCH.get(TREE_VAL)(copy_head_node);

                d3.select(svg_chart).on("layout-complete", () => {
                    updateLeafLabelsDisplay(); 
                });
                
                let renderedTreePadding = svg_chart.style.paddingLeft || 0
                svg_chart.style.paddingLeft = `${renderedTreePadding + TREE_OFFSET}px`
            

                $("#TreeData").append(svg_chart);
                
                if (isLegendActive && LAST_METADATA_COLUMN_SELECTED !== null) {
                    // Regenerate the legend for the subtree using last selected field
                    colour_by_element(LAST_METADATA_COLUMN_SELECTED);
                }

                $(".leaf-node").each((i, elm) => {
                    // Maintain colour of already selected nodes
                    let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                    if(SelectedNodes.nodes.has(text.textContent)){
                        SelectedNodes.nodes.set(text.textContent, parent); // update to new parent
                        SelectedNodes.setSelectedColours(text, circle);
                    }
                });
            }
    
            //updateLeafLabelsDisplay();

            
        };

        // Helper function to recurse through child nodes
        let RecurseTree = (data) => {
            let children = new Array;
            let ids = new Array;
            children.push(...data._children);
            while (children.length){
                let child = children.pop();
                if(!child._children){
                    ids.push(child.data.name);
                }else{
                    children.push(...child._children)
                }
            }
            return ids;
        };




        // Select all children of an inner-node
        let SelectChildren = (event, data) => {
            const circle_pos = SelectedNodes.getCirclePos();
            const trg_name_pos = SelectedNodes.getNamePos(); 

            // D3 functions to collect the sub-tree do not appear to be working here
            let selected_children = RecurseTree(data);
            let selected_children_jq = `#TreeSVG [id='${selected_children.join("'], #TreeSVG [id='")}']`;
            $(`${selected_children_jq}`).each((i, d) => {
                SelectedNodes.addNodes(d);
            })
            SelectedNodes.drawSelectedNodes();

        };


        let LeafNode = (event, d) => {
            d.children = d.children ? null : d._children;
            const circle_pos = 1;
            const trg_name_pos = 2;
            let parent = event.target.closest('g').childNodes;
            let trg = parent[circle_pos];
            let node_name = parent[trg_name_pos].textContent;
            if(d.data.leaf){
                if(trg.style.fill === clicked_color){
                    SelectedNodes.unselectNode(event.target);
                }else{
                    SelectedNodes.addNodes(event.target);
                }
            }
        };

        let switchTreeType = (eve) => {
            TREE_VAL = eve.id
            document.getElementById("dropdown_tree_types").setAttribute("data-current-layout", TREE_VAL);
            $('#colour-legend').empty()
            $('#colour-legend').addClass('d-none')
            $('#TreeSVG').remove();
            $("#scale-bar-menu").remove()
            let chart_ = null;
            if(tree_root !== null){
                chart_ = TREE_SWITCH.get(TREE_VAL)(tree_root);
                console.debug("Switching chart type via renderer function selected ", TREE_SWITCH.get(TREE_VAL).name);
                chart_.style.paddingLeft = chart_.style.paddingLeft + TREE_OFFSET;
                $("#TreeData").append(chart_);
                d3.select(chart_).on("layout-complete", () => {
                  updateLeafLabelsDisplay(); 
                });
                $(".leaf-node").each((i, elm) => {
                let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                if(SelectedNodes.nodes.has(text.textContent)){
                        SelectedNodes.nodes.set(text.textContent, parent); // reset dom position
                        SelectedNodes.setSelectedColours(text, circle);
                    };
                });
                reset_zoom_slider();
                return true;
            }
        };

        
        function extractAllMetadataJoined(selectedFields) {
            const MetaDataMap = new Map();

            // Validate the global ORIGINAL_DATA
            if (!ORIGINAL_DATA || !(ORIGINAL_DATA instanceof Map)) {
                console.warn("ORIGINAL_DATA is not defined or not a Map.");
                return MetaDataMap;
            }

            // Determine indexes of selected fields in the header
            const selected_indexes = selectedFields.map(field => TABLE_HEADERS.indexOf(field));
            if (selected_indexes.includes(-1)) {
                console.warn("Some selected fields not found in TABLE_HEADERS.");
            }
            if (selected_indexes.length === 0) {
                console.warn("No selected metadata field indexes specified.");
                return MetaDataMap;
            }
            
            // Track the lenght of the largest element in the table
            const maxLabelLengths = new Array(TABLE_HEADERS.length).fill(0); 
            let maxIDLength = 0;
            
            /*
              labelsUpdate will contain an array of the key and their updated
              labels to display. The array will not be processed into it's string view 
              until it is time to update the map as the max length is required to calculate 
              the required padding for each element
            */
            const labelsUpdate = new Array();
            ORIGINAL_DATA.forEach((row, key, table) => { 
              if (!row || !Array.isArray(row)) {
                    console.warn(`Invalid row for sampleID ${sampleID}`);
                    return; // Return functions as continue in a for each loop
              }
              maxIDLength = Math.max(key.length, maxIDLength);
              const selectedValues = selected_indexes.map((i) => {
                                        let row_label = String(row[i] ?? "").trim();  // ?? preserves '0', empty strings, and false. It only replaces null/undefined.
                                        /** @remarks
                                          fromCodePoint retrieves the the horizontal unicode elipse so that the charactar is rendered nicely.
                                        */
                                        row_label = row_label.length > LABEL_TRUNCATE_SIZE ? 
                                          `${row_label.slice(0, LABEL_TRUNCATE_SIZE)}${String.fromCodePoint(0x2026)}` 
                                          : row_label
                                        let labelLength = row_label.length;
                                        maxLabelLengths[i] = Math.max(maxLabelLengths[i], labelLength);
                                        return row_label;
                                      });
              labelsUpdate.push([key, selectedValues]);
            })


            for(const item of labelsUpdate){
              let padded_id = item[0].padEnd(maxIDLength, " ");
              let labels = [padded_id];

              labels.push(...item[1].map((ele, i) => {
                // For each selected index, we can get the maxLabelLength
                let maxLabelLength = maxLabelLengths[selected_indexes[i]];
                // The padEnd function will pad a given value to be certain length
                return ele.padEnd(maxLabelLength, " ");
              }));
              
              
              MetaDataMap.set(item[0], labels.join(" | "))
            }


            return MetaDataMap;
        }

        let cloneD3NodeData = (node) => {
            if (!node) return null;

            // Create a new object for the current node's raw data.
            // This copies properties like 'name', 'length', and any other custom data.
            let clonedData = { ...node.data }; 

            // If the node has children (which are also D3 node objects),
            // recursively clone their data to build the new hierarchy.
            if (node.children) {
                clonedData.children = node.children.map(childNode => cloneD3NodeData(childNode));
            }

            // The 'parent' property (and D3's internal 'x', 'y', 'depth', 'height' etc.)
            // are properties of the D3 node object itself, not typically part of your
            // raw 'data' object. By only copying 'node.data' and recursively handling
            // 'node.children', we naturally avoid the circular 'parent' reference.
            return clonedData;
        };

        let drawTree = (newick_) => {
            $("#tree-splash").remove()
            $("#tree-selector").remove()
            $("#tree-upload-button").remove()
            $("#scale-bar-menu").remove()
            let tree = kn_parse(newick_);
            
            if(tree_root != null){
                console.error("A tree is already drawn");
                return false;
            }
            //Store the root for later access (used in updates, selections, etc.)
            //Do that only ONCE during initial tree loading from Newick file
            if(tree_root === null){
                tree_root = tree.root; // Save the tree original tree root to redraw the tree when needed
            }    
            

            // Retrieve the rendering function from TREE_SWITCH based on current selection
            // E.g. dendrogram_chart(), tidytree_chart(), dendrogram_circle(), cladeogram_chart()
            const treeRendererFunction = TREE_SWITCH.get(TREE_VAL);
            console.debug(`Applying rendering function ${treeRendererFunction.name}()`)

            if (typeof treeRendererFunction !== "function") {
                console.error("Invalid tree renderer function selected:", TREE_VAL);
                return false;
            }
            
            let renderedTree = treeRendererFunction(tree_root); 
            //Match #TreeData height
            const treeDataHeight = document.querySelector('#TreeData').offsetHeight;
            const treeData = document.querySelector('#TreeData');
            treeData.style.height = `${treeDataHeight}px`;
            
        
            let renderedTreePadding = renderedTree.style.paddingLeft || 0 //If left padding property is not defined assign zero and add offset
            renderedTree.style.paddingLeft = `${renderedTreePadding + TREE_OFFSET}px`;
 
            // Insert rendered svg tree into the DOM
            $("#TreeData").append(renderedTree);
            // Scroll to center horizontally
            document.querySelector('#TreeData').scrollTo(document.querySelector('#TreeData').scrollWidth/2,0)
        };

        
        let CreateDataTable = () => {
            
            data_table = $('#metadata').DataTable({
                //stateSave: true,
                scrollCollapse: true,
                "paging": true,
                "lengthMenu": [ [10, 25, 50, 100, -1], [10, 25, 50, 100, "All"] ],
                className: ".editable",
                initComplete: function (settings, json) {
                    console.debug("DataTables has finished its initialization");
                    //listen to Enter keys
                    $('#metadata').on('keydown', 'td[contenteditable=true]', function (e) {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            
                            $(this).addClass('flash');
                            // Remove the class after the animation finishes
                            setTimeout(() => {
                                $(this).removeClass('flash');
                                $(this).blur(); //Act as if the user clicked away from editable cell.*/
                            }, 500); // duration matches the CSS flash animation
                            
                            
                        }
                    });

                    //Add STICKY HEADERS to the table 
                    document.querySelectorAll('#metadata thead th').forEach(th => {
                        th.style.position = 'sticky';
                        th.style.top = '0';
                        th.style.zIndex = '2'; // Make sure it's above table content
                        th.style.backgroundColor = 'white'; // Optional: avoid content showing through
                    });
                    
                    
                },
                columnDefs: [{
                        targets: '_all',
                        createdCell : (td, cellData, rowData, row, col) =>
                        {
                            if(col != 0){ // Skip ID column as it should not be editable
                                td.setAttribute('contenteditable', true);
                            }
                        }
                    }
                ],
                //dom: 'lfrtip',
                drawCallback: function(){
        
         
         
                //html.innerHTML='<div class="paginate_button displayAll">DISPLAY ALL RECORDS</div>'
         
         
                //let icon=document.create("i")
                ///icon.style="position:absolute; top:0; right: 0; cursor: pointer; color:blue; margin-right:1px"
                //icon.id="tree_fullscreen_btn"
                //icon.onclick="tree_full_screen_mode()"

                $('#metadata_length').addClass('p-1');

                let html=document.createElement("div");
                html.className = "paginate_button displayAll"
                html.id = "paginate_button_all"
                html.textContent = "ALL records"
                if(document.querySelector("#paginate_button_all") === null){
                    document.querySelector("#metadata_paginate").appendChild(html)
                }


                $('.paginate_button.displayAll:not(.disabled)', this.api().table().container())          
                .on('click', function(){
            
                    if(data_table.context[0]._iDisplayLength !== -1){
                        console.debug("Paginate OFF")
                        
                        data_table.context[0]._iDisplayLength=-1; //remove pagination
                        data_table.draw();
                        $('#metadata_length select').val(-1); //change "Show X entires" selector to ALL value
                        
                        $('#paginate_button_all').text("First 10")
                        console.debug(this.textContent)
                        
                    }else{
                        console.debug("Paginate ON")
                        console.debug($('#paginate_button_all').text())
                        data_table.context[0]._iDisplayLength=10;
                        $('#metadata_length select').val(10); //change "Show X entires" selector to ALL value
                        //
                        data_table.draw();
                        $('#paginate_button_all').text("ALL records");
                        console.debug(this.textContent)
                        
                    }    
                
                });       
            }

            });

            
            $('#metadata_filter input').attr("id", "search-bar").attr("class", "table table-striped"); // Give search bar ID to squash warnings

            // Add Clear Filters button next to the search input
            const clearBtnIcon = $('<i>')
                .addClass('bi bi-filter-circle me-1'); // Bootstrap icon with some right margin

            const clearBtn = $('<button>')
                    .attr('id', 'reset-table-button')
                    .attr('name','ResetTable')
                    .attr('title', 'Clear filters applied to the metadata table')
                    .attr('data-bs-toggle', 'tooltip')
                    .attr('data-bs-placement','top')
                    .addClass('btn btn-sm btn-danger ms-2') // styling with Bootstrap classes
                    .append(clearBtnIcon)  
                    .append('Clear filters')
                    .on('click', function () {
                        ResetTable()
                        // Clear global filters in the search input box
                        data_table.search('').columns().search('').draw(); 
                    });

            $('#metadata_filter').append(clearBtn);

            let maximize_button_html=document.createElement("i");
                maximize_button_html.style = "cursor: pointer; color:blue; margin-right:1px"
                maximize_button_html.className="d-inline-flex p-1 fs-5 bi-arrow-up-right-square"
                maximize_button_html.id = "metadata_fullscreen_btn"
                maximize_button_html.setAttribute("onclick", "metadata_full_screen_mode()")
                if(document.querySelector("#metadata_fullscreen_btn") === null){
                    document.querySelector("#metadata_filter").appendChild(maximize_button_html);
                }
            
            // TODO initializing table from json object would minimize copies
            
            /**
             * INITIALIZE ORIGINAL_DATA MAP - Saving data as a map, to allow for updating of metadata
             * * We iterate through the DataTables API to build a global Map.
             * Instead of using .data(), we access the DOM nodes directly to extract
             * .textContent. This prevents symbols like '&' from being stored as '&amp;'.
             */
            ORIGINAL_DATA = new Map();
            data_table.rows().every(function (rowIdx, tableLoop, rowLoop) {
                // Get the actual <tr> row DOM element for this row
                const rowNode = this.node(); 
    
                // Extract the textContent from each <td> cell
                const rawValues = Array.from(rowNode.cells).map(td => td.textContent.trim());

                // Store raw metadata array as a Map based on first column treated as sampleID
                // Assuming ID_FIELD is the index of your ID column
                ORIGINAL_DATA.set(rawValues[ID_FIELD], rawValues);
            });
       
            
            // TODO This can likely be initialized in the above loop pushing to value 
            for(const [key, value] of ORIGINAL_DATA.entries()){
                value.push(false); // Append a key to flag whether the value has been modified    
            }
        };

        /**
         * Recalculates and applies the height of the #SelectedNodes panel
         * based on the current size of #TreeData and #tree_menu_buttons.
         */
        function adjustSelectedNodesHeight() {
            const treeData = document.querySelector('#TreeData');
            const menuButtons = document.querySelector('#tree_menu_buttons');
            const selectedNodes = document.querySelector('#SelectedNodes');
            const metadataTable = document.querySelector('#ClusterInfo');

            if (!treeData || !menuButtons || !selectedNodes) return;

            const availableHeight = Math.abs(treeData.offsetHeight - menuButtons.clientHeight-12);
            // Optionally guard against too-small values:
            const minHeight = 100; 
            selectedNodes.style.height = `${Math.max(availableHeight, minHeight)}px`;
        }

        /**
         * Creates and populates an HTML table with parsed metadata, then initializes a DataTable.
         *
         * This function removes existing UI elements related to loading and metadata selection,
         * dynamically constructs the table header and body from the provided data and headers,
         * injects the resulting HTML into the specified table element by table_id variable, 
         * and then applies the
         * DataTables jQuery plugin to enhance the table looks and add sorting, filtering, and pagination.
         *
         * @param {Array<Object>} parsed_data - Array of objects representing metadata rows.
         *   Each object should contain properties corresponding to the headers.
         * @param {string} table_id - jQuery selector string for the target table element (e.g., "#myTable").
         * @param {Array<string>} table_headers - Array of strings specifying column headers and
         * keys to access in each metadata object.
         */
        let CreateTable = (parsed_data, table_id, table_headers) => {
            $("#table-splash").remove();
            $("#metadata-selector-input").remove();
            $("#metadata-selector").remove();
            let headers = table_headers;
            //let table_head = "";
            let table_body = [];
            
            let table_head = "<tr>";
            for (const item of headers) {
                table_head += `<th>${item}</th>\n`;
            }
            table_head += "</tr>";

            //for(const item of headers){
            //    table_head = table_head + `<th>${item}</th>\n`;
            //}
            for(const item of parsed_data){
                table_body.push('<tr>\n');
                for(const header of headers){
                    table_body.push(`<td class="editable">${item[header]}</td>\n`);
                }
                table_body.push("</tr>\n");
            }

            parsed_data = null; // mark old data for GC and cleanup memory 
            $(table_id).html("<thead>" + table_head + "</thead>" + "<tbody>" + table_body.join() + "</tbody>");
            // ? A bit odd we are making the table with HTML then converting to jquery datatable...
            CreateDataTable();
            adjustSelectedNodesHeight();
        };

        let CreateColoringGroups = (array_vals) => {
            let new_obj = new Object();
            for(const item of array_vals){
                new_obj[item] = new Array;
            }
            return new_obj;
        };

        function rgbToHex(r, g, b) {
            return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
        }

        function parseRBGstring(rbgString){
            m = rbgString.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if( m) {
                return [m[1],m[2],m[3]];
            }
        }

        //fill legend with items
        let CreateNodeLegend = (array_tuples, column_index, value2samples) => {

            let node_leg = $("#colour-legend")
            node_leg.empty()
            //Add the drag handle
            node_leg.append(`<div id="drag_legend_button" onmousedown="dragDivByMouse(event)" class="w-100" style="height:8px; background-color:blue; box-shadow: 1px 1px 1px 1px rgba(0,0,0,.8); cursor: all-scroll;"></div>`)
            
                        

            const columnName = TABLE_HEADERS[column_index] || `Unlabeled (column #${Number(column_index)+1})` //in case no column name is provided
            node_leg.append(`<div class="p-2 border-bottom bg-light text-center">
                                <strong>${columnName}</strong>
                            </div>`);

            for(const item of array_tuples.filter(tuple => tuple[0] !== '')){ //[field_value, hex_colour]
                let row_legend_node = $(`<div class="d-flex p-1 border-bottom flex-nowrap align-items-center legend-element"></div>`)
                let field_value=item[0]
                let count = (value2samples[field_value] || []).length;
                //if(field_value === ''){field_value="Not defined"}  
                row_legend_node.append(`
                <input type="color" value="${item[1]}" data-sampleID="${value2samples[item[0]].join(',')}"  onchange="changeLegendItemColour(this)" 
                style="width: 20px; height:20px; padding: 1px; border: 1px solid black"></input>\n
                <small data-fieldvalue="${field_value}" onclick="select_deselect_nodes_by_field_value(this, ${column_index})" 
                style="padding-left:5px">${field_value} (${count})</small>`)
                node_leg.append(row_legend_node)
            }
            document.querySelector('#colour-legend').classList.remove("d-none");
            document.querySelector('#colour-legend').style.left = `${document.querySelector('#TreeData').scrollLeft}px`

        };
        

        let lineThickness = (ele) => {
            if(ele){
                LINE_THICKNESS = ele.value;
            }
            $("#line-thickness-value").html(`${Number(LINE_THICKNESS).toFixed(1)}`);
            $(".adjustable-line").css('stroke-width', LINE_THICKNESS)
        }


        let changeLegendItemColour = (div) => {
            let prevColourValueHex = div.getAttribute("value");
            let newColourValueHex = `${div.value}`
            div.setAttribute("value",newColourValueHex);
            let legend_update = div.nextElementSibling.innerText;
            div.dataset.sampleid.split(',').forEach( sample_id => {
                let ele = document.querySelector(`#TreeSVG [id="${sample_id}"]`);
                if(ele !== null){
                    let [elem, circle, text] = SelectedNodes.getNodeData(ele);
                    if(SelectedNodes.nodes.has(text.textContent)){
                        // if selected old fill value needs to be updated
                        circle.dataset.oldfill = newColourValueHex;
                    }else{
                        circle.style.fill = newColourValueHex;
                    }
                    
                }
            })

        }

        let PopulateGroups = (json_groups, query_key) => {

            ORIGINAL_DATA.forEach((value, key) => {
                if (value[query_key] in json_groups) {
                    json_groups[value[query_key]].push(key);
                }
                
            });
            return json_groups;
        };

        let ResetTable = () => {
            data_table.clear();
            // ? Is there a more space efficient way to do this?
            data_table.rows.add(Array.from(ORIGINAL_DATA.values())).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);
        };

        let SubsetTable = () => {
            let totalSamples = data_table.rows().count();;
            let filtered = data_table.data().filter((value, idx) => {
                return SelectedNodes.nodes.has(value[ID_FIELD]);
            });
            let remainingSamples = filtered.length;
            let filteredOutSamplesCount = totalSamples - remainingSamples;
      
            data_table.clear();
            data_table.rows.add(filtered).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);

            Swal.fire({
                title: 'Metadata Table Subsetted based on Selected Nodes',
                html: `<b>${remainingSamples}</b> samples kept out of <b>${totalSamples}</b>.<br>` + 
                    `<small class="text-muted"><b>${filteredOutSamplesCount}</b> samples were filtered out.</small>`,
                icon: 'success',
                timer: 5000,
                timerProgressBar: true,
                showConfirmButton: false,
                toast: true,
                position: 'top-end'
            });

        };


        /**
         * Initializes and updates UI properties of 'legend_dropdown_button' and 'metadata_fields_dropdown_button'  buttons.
         *
         * This function targets two specific dropdown buttons by their IDs:
         * `#legend_dropdown_button` and `#metadata_fields_dropdown_button`.
         * It sets appropriate button text, ensures they are marked as Bootstrap dropdown toggles,
         * and updates the button style from `btn-danger` to `btn-primary` if applicable.
         *
         *
         * Modifies:
         * - Button text content
         * - `data-bs-toggle` attribute so they are clickable
         * - Bootstrap button classes (`btn-danger` to `btn-primary`)
         *
         * @function initialize_legend_menu
         * @returns {void}
         */
        let initialize_legend_menu = () => {
            const buttonIds = ["#legend_dropdown_button", "#metadata_fields_dropdown_button"];

            buttonIds.forEach(id => {
                const button = document.querySelector(id);
                if (!button) return;

                // Update button text based on button ID
                if (id === "#legend_dropdown_button") {
                    button.textContent = "Colour tree by column";
                } else if (id === "#metadata_fields_dropdown_button") {
                    button.textContent = "Add metadata to nodes";
                }

                button.dataset.bsToggle = "dropdown";

                // Replace btn-danger with btn-primary if exists
                if (button.classList.contains("btn-danger")) {
                    button.classList.remove("btn-danger");
                    button.classList.add("btn-primary");
                }

            });
        };

        /**
         * Initializes and renders the tree layout selection menu allowing to change layouts.
         *
         * This function updates the tree layout selection dropdown menu values.
         * It generates a list of available tree layout options based on the keys
         * of the global `TREE_SWITCH` map gloabal variable. Each tree layout option is rendered as a clickable
         * dropdown item that, when selected, calls `switchTreeType(this)` with the
         * chosen tree layout identifier.
         *
         * @function initialize_tree_menu
         * @returns {void}
         */
        let initialize_tree_menu = () => {
            let button = document.querySelector("#tree_dropdown_menu")
            button.textContent = "Select a tree layout"
            button.dataset.bsToggle = "dropdown";
            let tree_types = new Array;
            tree_types.push('<div class=\"dropdown-menu\" id=\"tree-layouts\" style=\"overflow:visible;\">')
            TREE_SWITCH.keys().forEach( (ele) => {
                tree_types.push(`\t<a onclick="switchTreeType(this)" class="dropdown-item" href="#" id="${ele}">${ele}</a>`)
            })
            $("#dropdown_tree_types").append(tree_types.join("\n"))

        }

        /**
         * Updates the text labels of all rendered leaf nodes in the existing D3 SVG tree.
         * 
         * Each leaf node is expected to be a <g> element with the class `leaf-node` and an `id`
         * corresponding to the sample ID. The label is updated in the format: `<sampleID> | <joinedFields>`.
         * 
         * This function does not re-render the tree — it modifies the existing DOM structure.
         * 
         * @param {Map<string, string>} allDataMap - A map of sample IDs to metadata strings (joined fields),
         *                                           where the key is the leaf node ID and the value is the new label content.
         * 
         * @example
         * const MetaDataMap = new Map([
         *   ["SRR13243498", "Canada"],
         *   ["SRR13243499", "USA"]
         * ]);
         * updateLeafNodeLabels(MetaDataMap);
         */
         function updateLeafNodeLabels(MetaDataMap) {
            
            const svg = d3.select("#TreeSVG")
            const treeContainer = svg.select('g[cursor="pointer"][pointer-events="all"]')
            const treeDataContainer = document.querySelector('#TreeData');
            const svgAttrWidth = svg.attr("width")
            const oldWidth = treeContainer.node().getBBox().width
            const currentLayout = document.getElementById("dropdown_tree_types").getAttribute("data-current-layout");
            const isRadial = currentLayout === "Radial Dendrogram"

            
            if (treeContainer.empty()) {
                console.warn("Main tree container group not found.");
                return;
            }

            if (svg.empty()) {
                console.warn("Tree SVG not found.");
                return;
            }

            //update leaf nodes update labels
            const isEmpty = !MetaDataMap || MetaDataMap.size === 0;

            const selectedFields = Array.from(document.querySelectorAll('#dropdown_append_metadata2nodes .metadata-field-checkbox:checked'))
                .map(cb => cb.value);

            console.debug("User selected these fields:", selectedFields);
                        
            let missingMetadataNodes = new Set();
            svg.selectAll("g.leaf-node").each(function () {
                const g = d3.select(this);
                const nodeId = this.id;
                
                if (isEmpty) {
                    newLabel = `${nodeId}`;
                } else {
                    const joinedFields = MetaDataMap.get(nodeId);
                    const hasValue = typeof joinedFields === "string" && joinedFields.trim() !== "";
                    if (!hasValue) missingMetadataNodes.add(nodeId);
                    /** @remarks
                      Removed the .trim() on joinedFields as the whitespace is required for padding.
                      trimEnd()  would work, but if we had more options for justifying text in 
                      the future in may create some problems.
                    */
                    
                    newLabel = hasValue ? `${joinedFields}` : nodeId;
                }
                g.selectAll("text")
                    .filter(function () {
                        // Only update text elements that start with the nodeId
                        return d3.select(this).text().startsWith(nodeId);
                    })
                    .attr("xml:space", "preserve") // Prevents SVG from collapsing your padding spaces
                    .text(newLabel).attr("class", "leaf-node-label");
            });
            if (missingMetadataNodes.size > 0) {
                console.warn(`Metadata missing for ${missingMetadataNodes.size} nodes:`, Array.from(missingMetadataNodes));
            }

            const bbox = treeContainer.node().getBBox();
            const newWidth = bbox.width+50 // add some padding as calculates the coordinates of the paths and shapes, but it does not include the width of the strokes
            //const newHeight = treeContainer.node().getBBox().height+20 // add some padding as calculates the coordinates of the paths and shapes, but it does not include the width of the strokes
        
            const viewBoxAttr = svg.attr("viewBox")
            if (!viewBoxAttr) {
                console.warn("viewBox not yet initialized by chart function.");
                return; 
            }
            let [minX, minY, width, height] = viewBoxAttr.split(/[\s,]+/).map(Number)
            // Update the width of the svg element
            //treeDataContainer.scrollLeft = newWidth;
            if (isRadial) {
                const fontSize=12;
                let longestLabel = "";
                // Prioritize the Metadata Map that is available upon node text addition from metadata
                if (MetaDataMap.size > 0) {
                    MetaDataMap.forEach((label) => {
                        if (label && label.length > longestLabel.length) {
                            longestLabel = label;
                        }
                    });
                } else {
                    // Fallback: If no metadata is loaded, check the Node IDs in the DOM
                    svg.selectAll("g.leaf-node").each(function() {
                        const nodeId = this.id;
                        if (nodeId.length > longestLabel.length) {
                            longestLabel = nodeId;
                        }
                    });
                }
                maxLabelPixels = estimateTextWidth(longestLabel, fontSize);
                height = newWidth;
                minY = -maxLabelPixels-5; // Add padding to account for label height
                minX = minY; //left margin also needs to be adjusted
            }


            svg.attr("width", newWidth)
               .attr("height", height)
               .attr("viewBox", `${minX} ${minY} ${newWidth} ${height}`)
            svg.style.overflow = "scroll";

            const maxScrollLeft = newWidth - treeDataContainer.clientWidth;
            treeDataContainer.scrollLeft = maxScrollLeft; //scroll to the right margin

          
        }

        /**
         * Attaches event listeners to all metadata checkboxes in the 
         * "Add metadata to nodes" dropdown menu. This function listens
         * for `change` events (i.e. when checkboxes are selected or deselected) 
         * and logs the selected field and its checked status.
         * **/
        function initializeMetadataFieldListeners() {
            const container = document.querySelector('#dropdown_append_metadata2nodes');
        
            if (!container) {
                console.warn("Dropdown container not found.");
                return;
            }

            
            // Select all items inside the dropdown menu based on label tag
            const dropdownMenu = container.querySelector('.dropdown-menu');
            
            if (!dropdownMenu) {
                console.warn("No .dropdown-menu found in metadata dropdown.");
                return;
            }
            
            const labels = dropdownMenu.querySelectorAll('label.dropdown-item');
            if (labels.length === 0) {
                console.warn("No label.dropdown-item elements found in .dropdown-menu.");
                return;
            }
            labels.forEach(label => {
                label.addEventListener('click', (event) => {
                   
                    const checkbox = label.querySelector('input[type="checkbox"]');
                    if (!checkbox) return;
                    
                    // If the actual target was the checkbox, let native behavior proceed
                    // Otherwise use manual checkbox turn on
                    if (event.target === checkbox) {
                        // Let the browser handle toggle if user clicks on input box directly
                    } else {
                        // Manually toggle if click was on label (not checkbox)
                        event.preventDefault(); // prevent default label toggle double click
                        checkbox.checked = !checkbox.checked;
                    }

                    // Log checked and unchecked fields
                    const allCheckboxes = dropdownMenu.querySelectorAll('input[type="checkbox"]');
                    const checkedFields = [];
                    const uncheckedFields = [];

                    allCheckboxes.forEach(cb => {
                        if (cb.checked) {
                            checkedFields.push(cb.value);
                        } else {
                            uncheckedFields.push(cb.value);
                        }
                    });

                    
                    // Extract all metadata already loaded as a map
                    const metadataJoinedMap = extractAllMetadataJoined(checkedFields);
                    // Append metadata to tree leaf nodes if available
                    if (metadataJoinedMap.size !== 0) {
                        updateLeafNodeLabels(metadataJoinedMap)

                    }else{
                        console.warn("The metadata table map is empty.");
                        updateLeafNodeLabels(metadataJoinedMap)
                    }

              
                }); //event
            });
        }
        


        /**
         * Dynamically creates and appends dropdown menu elements of the metadata fields
         *
         * This function handles rendering of dropdown menus for two different UI components:
         * - A single-select legend dropdown (`#dropdown_legend`) where a user selects ONE metadata field to color tree nodes.
         * - A multi-select metadata attachment dropdown (`#dropdown_append_metadata2nodes`) that allows users to check multiple metadata fields to annotate nodes.
         *
         * Each dropdown is rebuilt from scratch: any existing `.dropdown-menu` within the target container is removed and replaced
         * with a newly generated one based on the `headers` array.
         *
         * @function create_legend_elements
         * @param {string[]} headers - Array of metadata field names, with the first element typically being a sample ID (skipped).
         *
         * @example
         * create_legend_elements(["SampleID", "Host", "Country", "Collection Date"]);
         *
         * Effects:
         * - Clears and repopulates `.dropdown-menu` elements inside target containers.
         * - Enables both single and multi-select interactions depending on the dropdown.
         */

        function create_legend_elements(headers) {
            if (!headers || headers.length < 2) return;

            const metadataFields = headers.slice(1); // skip sample ID

            // Define target dropdowns and whether they should be multi-select
            const dropdowns = [
                { selector: '#dropdown_legend', multiSelect: false },
                { selector: '#dropdown_append_metadata2nodes', multiSelect: true }
            ];

            dropdowns.forEach(({ selector, multiSelect }) => {
                // Clear any existing dropdown-menu
                const container = document.querySelector(selector);
                if (!container) return;

                // Remove old dropdown menu if exists
                const oldMenu = container.querySelector('.dropdown-menu');
                if (oldMenu) container.removeChild(oldMenu);

                const button = container.querySelector('button');
                const rect = button.getBoundingClientRect();

                const distanceToTop = rect.top; //Distance from the top of the button to the top of the screen
                const distanceToBottom = window.innerHeight - rect.bottom;//Distance from the bottom of the button to the bottom of the screen
                const dynamicMaxHeight = Math.max(distanceToTop, distanceToBottom) - 20;

                if (distanceToTop > distanceToBottom) {
                    container.classList.add('dropup');
                } else {
                    container.classList.remove('dropup');
                }


                const dropdown = document.createElement('div');
                dropdown.className = 'dropdown-menu';
                dropdown.style.overflow = 'visible';
                dropdown.style.maxHeight = `${dynamicMaxHeight}px`;
                dropdown.style.overflow = 'auto';
                dropdown.style.whiteSpace = 'nowrap';
                dropdown.style.marginLeft = '4px';
                dropdown.style.minWidth = `${button.offsetWidth + 8}px`;

                

                metadataFields.forEach((field, index) => {
                    if (multiSelect) {
                        // Multi-select item with checkbox "add metadta to nodes" button
                        const label = document.createElement('label');
                        label.className = 'dropdown-item d-flex align-items-center';
                        label.style.cursor = 'pointer';

                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.className = 'metadata-field-checkbox me-2';
                        checkbox.id = `metadata-field-${index + 1}`;
                        checkbox.value = field;

                        label.appendChild(checkbox);
                        label.appendChild(document.createTextNode(field));
                        dropdown.appendChild(label);
                        
                    } else {
                        // Single-select item with link
                        const link = document.createElement('a');
                        link.className = 'dropdown-item';
                        link.href = '#';
                        link.id = `${index + 1}`;
                        link.textContent = field;
                        link.setAttribute('onclick', 'colour_by_element(this)');
                        dropdown.appendChild(link);
                    }
                });

                // Append new one
                container.appendChild(dropdown);
                
                // Attach label listeners if this is the metadata multi-select dropdown
                if (selector === '#dropdown_append_metadata2nodes' && multiSelect) {
                    initializeMetadataFieldListeners();
                }
                });
        }
        
        
        let colour_by_element = (ele) => {
            LAST_METADATA_COLUMN_SELECTED = ele;
            // Create a legend for the column selected
            if(tree_root === null){
                // TODO add pop up
                console.error("No newick loaded")
                return null
            }

            let col_index = ele.id;
            
            $("#legend_toggle").bootstrapToggle('on')

            let unq_data = new Set();
            ORIGINAL_DATA.forEach((value, key) => {
                unq_data.add(value[col_index])
            })


            // Need to create GLOBAL TREE groupings of the each set of ID's belonging to each value grouping
            let break_down_values = Array.from(unq_data);
            break_down_values.sort()
            
            // Instead of searching the array for ID's using the datatable, I am just going to use a linear look up
            let group_vals = CreateColoringGroups(break_down_values); // {"unique_item":[],"unique_item2":[]}
            break_down_values = PopulateGroups(group_vals, col_index); //{"unique_item":["id1","id2"...],"unique_item2":["id3"]}
            

            let colours = randomColor({luminosity: 'dark', count: Object.keys(break_down_values).length, seed: 42, format: "hex"});
        
            /* Heuristic algorithm to pick non-overlapping colours above threshold */ 
            
            //given a random colours for legend items find highly similar colours below the deltaE2000 threshold
            if(colours.length <= 50){
                const deltaE2000_threshold = 10;
                let problematic_colours_idx=[];
                colours.map((picked_color, j)=>{
                
                    //find highly similar colours in a panel below deltaE2000_threshold
                    for (const [i,legend_color] of colours.entries()){
                        let deltaE2000 = Color.deltaE2000(picked_color, legend_color)
                        if(deltaE2000 <= deltaE2000_threshold && deltaE2000 !== 0){
                            problematic_colours_idx.push(i)            
                        }

                    }//for loop ends

                    problematic_colours_idx = [ ... new Set(problematic_colours_idx)].sort((a,b)=> a-b)
                
                });

                console.debug(`Found problematic too similar ${problematic_colours_idx} with indices ${problematic_colours_idx.length} out of ${colours.length}`)    
                
                //if highly similar colours in legend found, try to find a suitable replacement that will be above the deltaE2000_threshold
                //try randomly pick 1000 colours and test them against all colours in the legend
                let found_new_color_bool = false;
                problematic_colours_idx.forEach(i =>{
                    found_new_color_bool = false
                 
                    const seed_offset = parseInt(Math.random()*100000)+1;
                    const max_random_colours = 1000;
                    colour_random_list = randomColor({ seed: seed_offset, count: max_random_colours, format:'hex'})
                
                    for(const random_color_hex of colour_random_list) {
                        //check distance to all colours in the legend
                        let deltaE2000_list = colours.map(legend_color => {
                            return Color.deltaE2000(random_color_hex, legend_color)
                        });
                        let minDeltaE2000 = Math.min(...deltaE2000_list)
                    
                        if(minDeltaE2000 > deltaE2000_threshold){
                            console.debug(`Found a suitable color ${random_color_hex} with min deltaE2000 ${minDeltaE2000} for ${Object.keys(break_down_values)[i]}`)
                            colours[i] = random_color_hex;
                            found_new_color_bool = true;
                            break;
                        }
                    }//for      
                    
                });//forEach ends 
            }//if ends

            //colour each leaf nodes with the selected colour
            let colour_idx = 0;
            colour_legend.length = 0; // clear out old data, so new legend created each time
            
            for (const nodeId of SelectedNodes.nodes) {
                console.debug(nodeId); // This will log each node ID in the Set
            }
            // This local object will hold only the nodes currently in the DOM
            // Relevant when generating the legend for subtrees 
            let visible_breakdown = [];
            for(const item in break_down_values){
                let nodes_found_for_this_category = []; //checks if node exists in DOM now
                if (item === "" || item === null) continue; //Skip empty field values (leaves them uncoloured/hidden from legend)

                break_down_values[item].forEach((x, i) => {
                    
                    //check if the node exists in the DOM (e.g. subtree case)
                    if(document.getElementById(x)){
                    
                        try{
                            let current_item = document.querySelector(`[id='${x}']`);
                            let [elem, circle, text] = SelectedNodes.getNodeData(current_item);
                            nodes_found_for_this_category.push(x);
                            circle.dataset.oldfill = circle.style.fill || SelectedNodes.getDefaultColour();
                            circle.style.fill = colours[colour_idx];
                                
                        }catch(error){
                                console.error("Could not find node ", x, " in DOM");
                                console.error(error); 
                        }
                    }
                });

       
                if (nodes_found_for_this_category.length > 0) {
                    colour_legend.push([item, colours[colour_idx]])
                    visible_breakdown[item] = nodes_found_for_this_category;
                    colour_idx++;
                }
            }
         
            CreateNodeLegend(colour_legend, col_index, visible_breakdown);    

        };
        

        let updateLeafLabelsDisplay = () => {
          const checkedBoxes = document.querySelectorAll('#dropdown_append_metadata2nodes .dropdown-menu input[type="checkbox"]:checked');
          const metadataMap = extractAllMetadataJoined([...checkedBoxes].map(i => i.value)) 
          if (metadataMap.size !== 0) {
            updateLeafNodeLabels(metadataMap)
          }else{
            console.warn("The metadata table map is empty.");
            updateLeafNodeLabels(metadataMap)
          }
        }
          

        let redrawTree = () => {
            



          $('#colour-legend').empty()
          $('#colour-legend').addClass('d-none')
          $("#scale-bar-menu").remove()
          $('#TreeSVG').remove();

          let tree_drawn = () => {
            let chart_ = null;
            if(tree_root !== null){
                chart_ = TREE_SWITCH.get(TREE_VAL)(tree_root);
                let renderedTreePadding = chart_.style.paddingLeft || 0
                chart_.style.paddingLeft = `${renderedTreePadding + TREE_OFFSET}px`
                
                $("#TreeData").append(chart_);
                // This is the listener the layout-complete event (i.e. when the tree is fully rendered)
                // d3.select(chart_) converts the DOM element into a D3 selection to access D3 methods like .on() event listener
                
                d3.select(chart_).on("layout-complete", () => {
                    /**@remarks
                    Previously, a `setTimeout` of 500 ms was used inside the updateLeafLabelsDisplay() to wait for the browser to finish rendering labels. 
                    Without this wait, `getBBox()` would return "stale" old dimensions before the leaf nodes text was 
                    updated to wider dimensions, causing the labels to be clipped.

                    Specifically, the `setTimeout` function was required as this function executes
                    before the svg is rendered in the main window resulting in no viewBox
                    this results in the viewBox width not being increased resulting in cut off
                    labels. the timeout allows for this function to execute when the svg actually exists.

                    We now use a 0-duration D3 named transition ("tree-layout") to solve this more reliably:

                    1) The named transition ensures our code hooks directly into the D3 rendering events.

                    2) The "layout-complete" event fires only after the browser has finished calculating the new physical sizes 
                    and positions of the SVG Tree element.
                    This ensures we always get the accurate width for the viewBox and eliminates artificial lag for 
                    fast computers and prevents errors on slower hardware where 500ms might not have been enough time to finish rendering.
                    */
                    updateLeafLabelsDisplay(); 
                });
                $(".leaf-node").each((i, elm) => {
                    let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                    if(SelectedNodes.nodes.has(text.textContent)){
                        SelectedNodes.nodes.set(text.textContent, parent); // reset dom position
                        SelectedNodes.setSelectedColours(text, circle);
                };
                  });
            }else{
              console.error("No tree to redraw");
            }
          }
          tree_drawn();
          reset_zoom_slider();
          


        }

        $(() => {


            $("#redraw-tree-button").on("click", () => { 
              redrawTree(); 
            });

            initialize_tree_menu();
            lineThickness();


            // ! Below disables the right click menu for the page
            document.oncontextmenu = (event) => {
                // Disables context menu for TreeData div, e.g. default web menu does not appear
                let item_id = event.target.closest("div").id;
                return true;
            };

            // Check if TREE is defined or injected via the inline_arborview.py script (used by Arborator and GAS)
            if(TREE != __DEADBEEF__){
                // If a valid TREE variable is defined
                if(TREE != __DEADBEEF__){
                    // Render the actual TREE data
                    drawTree(TREE);
                }
            }

            $("#tree-selector").change((event) => {
                let reader = new FileReader();
                let newick_file = event.target.files[0];
                reader.readAsText(newick_file, "UTF-8");
                console.debug(`Successfully loaded ${newick_file.name}`)
                reader.onload = (evt) => {
                    newick = evt.target.result;
                    drawTree(newick);
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${newick_file}`);
                };
            });


            $("#ResetTree").on("click", (evt) => {
                
                if(focused_element !== null){
                    // Revert any focused node back to its original colours
                    // TODO perhaps this should be dropped as there is a redraw tree option
                    focused_element.setAttribute('fill', "black");
                }
                let svg = document.querySelector('#TreeSVG')
                let og_box = svg.getBBox();
                svg.style.width = `${og_box.width}`
                //scroll to middle of the div
                document.querySelector('#TreeData').scrollLeft = document.querySelector('#TreeData').clientWidth/2
                reset_zoom_slider()
            });


            $("#metadata").on("blur", ".editable", (evt)=>{
                // Update element        
                let row_values = evt.target.closest("tr").childNodes;        
                let edited_value = row_values[0].textContent;
                let retrieved_value = ORIGINAL_DATA.get(edited_value);
                let retrieved_val_length = retrieved_value.length;
                let updated_bool_pos = retrieved_val_length -1; // last value in list is a boolean for wether the data has been modified

                let updated = false;
                for(let i = 0; i < updated_bool_pos; i++){ 
                    if(row_values[i].textContent !== retrieved_value[i]){
                        // can alternatively use str1.localeCompare(str2)
                        retrieved_value[i] = row_values[i].textContent;
                        updated = true
                    }
                    
                }

                // only update the row if the values are new
                if(updated){
                    retrieved_value[updated_bool_pos] = true;
                }
            });

            if(DATA != __DEADFOOD__){
                /*
                Optimization Note:

                Initially just pasting in the string for the metadata which may or may not be a good thing...
                
                It could be slow due to the over head of the object existing as text in the page and in memory
                TODO remove selectors
                */

                // Create METADATA to load in
                let processing = true;
                const blankQuitter = (d, i) => {
                        const blankRow = Object.keys(d).every(k => !d[k]);
                        if (blankRow) processing = false;
                        if (processing) return d;
                }
                METADATA = d3.tsvParse(DATA, blankQuitter);
                TABLE_HEADERS = METADATA.columns;
                
                CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                METADATA = null;
                initialize_legend_menu();
                //$("#dropdown_legend").append(create_legend_elements(TABLE_HEADERS));
                $("#dropdown_legend, #dropdown_append_metadata2nodes").append(create_legend_elements(TABLE_HEADERS));
            }

            $("#metadata-selector").change((event) => {
                let reader = new FileReader();
                let metadata_file = event.target.files[0];

                reader.readAsText(metadata_file, "UTF-8");
                reader.onload = (evt) => {
                    // TODO scrub empty rows on reading, e.g. force a sample id to be filled
                    let metadata = evt.target.result;
                    // Blank quitter function from: https://stackoverflow.com/questions/67793952/is-there-an-easy-way-to-stop-d3-csvparse-when-it-hits-a-blank-line
                    let processing = true;
                    const blankQuitter = (d, i) => {
                        const blankRow = Object.keys(d).every(k => !d[k]);
                        if (blankRow) processing = false;
                        if (processing) return d;
                    }
                    METADATA = d3.tsvParse(metadata, blankQuitter);
                    TABLE_HEADERS = METADATA.columns;

                    CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                    METADATA = null;
                    initialize_legend_menu();
                    $("#dropdown_legend").append(create_legend_elements(TABLE_HEADERS));
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${metadata_file}`);
                };
                
            });

            $("#metadata-search-button").on('click', SubsetTable);
            $("#reset-table-button").on('click', ResetTable);


            $("#metadata").on( "dblclick", "tr:not(:first) td:first-child", function(evt) {
                console.debug(`trying to add ${evt.target.textContent}`)
                
                let tree_node = document.querySelector( `[id='${evt.target.textContent}']`)
                let text = tree_node.lastChild
                let circle = tree_node.querySelector('circle')
                if(SelectedNodes.nodes.has(text.textContent)){
                    SelectedNodes.unselectNode(text);
                }else{
                    SelectedNodes.addNodes(text);
                }

                SelectedNodes.drawSelectedNodes();
                
            } );



            // TODO need to change from sorting_1, to  :first
            // Zoom in on a NODE on single click event
            $("#metadata").on('click', 'tr td:first-child', (evt) => {
                console.debug(`ZOOMING on node selected in metadata table ${evt.target.textContent}`)
                
                let identified_point = document.querySelector(`[id='${evt.target.textContent}']`)
                let identified_point_id = identified_point.childNodes[0].textContent; // gets nodes name
                let is_selected = SelectedNodes.nodes.has(identified_point_id);
                let is_selected_focus = false;
                if(focused_element !== null){
                    is_selected_focus = SelectedNodes.nodes.has(focused_element.childNodes[0].textContent);
                }
                
                // if there is a foucsed item, the new focused item is not selected and the focused item is not selected
                // set its texts to black
                if(focused_element !== null && !is_selected_focus){
                    // Return elements state unless it is already adjusted due to being selected 
                    focused_element.childNodes[2].style.fill = "black";
                }
                focused_element = identified_point; // Save reference to new point

                if(!is_selected){
                    // Highlight selected item unless it is already highlighted due to being selected
                    console.debug("Selected element", identified_point)
                    identified_point.childNodes[2].style.fill = clicked_color;
                }
                
                let rect = identified_point.getBBox();
                let translated_coords = identified_point.getAttribute('transform').replace('translate(', '').replace(")", '').split(",");
                let rect_x = parseFloat(translated_coords[0]);
                let rect_y = parseFloat(translated_coords[1]);
                let svg = document.querySelector('#TreeSVG')
                
                //delay execution so that double click event is possible on the metadata row
                setTimeout(function() {
                    scroll_into_view_treenode(`${evt.target.textContent}`)
                },500);    
                
            });

            $("#TreeData").on('scroll', '#TreeSVG', (evt) => {
                console.debug("scrolling");
            });

        });


        
        zoom_tree = function(){
            
            const zoom_times = parseFloat(document.querySelector('#zoom_slider').value)
            const tree_data_elm = document.querySelector('#TreeData')
            const tree_svg = document.querySelector('#TreeSVG')
            document.querySelector('#zoom_slider_value').textContent =  zoom_times 

            const content_bbox = tree_svg.getBBox(); //content bounding box of the Tree SVG

            // Define the base coordinate width (unzoomed) including your offset
            const base_coordinate_width = Math.max(ORIGINAL_WIDTH_SVG + TREE_LEFT_MARGIN_VIEWBOX_OFFSET + 20,
                                            content_bbox.width + content_bbox.x + 50); //20 for right margin padding
            const current_vb = tree_svg.viewBox.baseVal; //current viewBox values
            const base_coordinate_height = current_vb.height; //the unzoomed height of the tree.

            //Calculate new physical dimensions of width and height as both must be scaled for zoom to work
            const new_width = base_coordinate_width * zoom_times 
            const new_height = base_coordinate_height * zoom_times

            //Get the previous physical width before zooming
            const prev_width = parseFloat(document.querySelector('#TreeSVG').style.width) || base_coordinate_width;
            const prev_height = parseFloat(document.querySelector('#TreeSVG').style.height) || base_coordinate_height;

            //Previous x and y scroll positions before applying a zoom
            const prev_x_scroll_pos = tree_data_elm.scrollLeft
            const prev_y_scroll_pos = tree_data_elm.scrollTop

            //document.querySelector('#TreeSVG').style.width = new_width ; //modify width of SVG tree
            // svg width was not being properly set on firfox
            document.querySelector('#TreeSVG').setAttribute("width", `${new_width}`); //modify width of SVG tree
            document.querySelector('#TreeSVG').setAttribute("height", `${new_height}`); //modify height of SVG tree

            // This is what makes the tree actually look bigger inside the new width/height
            tree_svg.setAttribute("viewBox", `${-TREE_LEFT_MARGIN_VIEWBOX_OFFSET} ${current_vb.y} ${base_coordinate_width} ${base_coordinate_height}`);

            // Calculate the scale change factor for width and height
            const scaleChangeX = new_width / prev_width;
            const scaleChangeY = new_height / prev_height; 

            // Focus on the center of the current view for a smoother experience
            // Formula: (Current center point * scale) - half of the window
            const view_w = tree_data_elm.clientWidth;
            const view_h = tree_data_elm.clientHeight;

            // Calculate the physical "Boundaries" of the new scaled content.
            const maxPossibleX = new_width - view_w;
            const maxPossibleY = new_height - view_h;

            // Calculate the theoretical scroll target that does not care if the result is possible given screen dims
            let targetX = (prev_x_scroll_pos + view_w / 2) * scaleChangeX - (view_w / 2);
            let targetY = (prev_y_scroll_pos + view_h / 2) * scaleChangeY - (view_h / 2);

            // This prevents the browser from fighting your scrollTo command
            zoom_x_translated = Math.round(Math.max(0, Math.min(targetX, maxPossibleX)));
            zoom_y_translated = Math.round(Math.max(0, Math.min(targetY, maxPossibleY)));
                    
            //Apply the final, safe coordinates preventing x-axis sliding effect on zoom out
            document.querySelector('#TreeData').scrollTo(zoom_x_translated, zoom_y_translated);


        }
        
        scroll_into_view_treenode = function(id){
            let selectedNode = document.querySelector(`[id='${id}']`)
            if(selectedNode !== null){
                selectedNode.scrollIntoView({block: "center", inline:"center", behavior: "smooth"})
            }else{
                console.error(`scroll_into_view_treenode(): Node ${id} is not available in this tree. Uncollapse all nodes`)
            } 
        }

        scale_bar_on_off = function(node){
            $(".scale-bar").css("visibility", () => {
                if(!node.checked){
                    return "hidden"
                }else{
                    return "visible"
                }
            })
        }

        legend_on_off = function(node){        
            const colourLegendElement = document.querySelector('#colour-legend');
            const isLegendOn = node.checked;

            function updateLeafNodeColors(isLegendOn) {
                document.querySelectorAll('g.tree-node.leaf-node > circle').forEach(circleElement => {
                    try {
                        if (!isLegendOn) {
                            // Logic for when the legend is OFF: set to default color
                            if (circleElement.style.fill !== "") {
                                circleElement.dataset.oldfill = circleElement.style.fill; // Store current fill
                            }
                            circleElement.style.fill = SelectedNodes.getDefaultColour(); // Apply #999
                        } else {
                            // Logic for when the legend is ON: restore or apply default
                            if (circleElement.dataset.oldfill) {
                                circleElement.style.fill = circleElement.dataset.oldfill; // Restore saved fill
                                delete circleElement.dataset.oldfill; // Clean up
                            } else {
                                // If no oldfill was saved (e.g., it was initially an empty string),
                                // apply the default leaf color.
                                circleElement.style.fill = SelectedNodes.getDefaultColour();
                            }
                        }
                    } catch (error) {
                        console.error("Error processing leaf circle element:", circleElement.id || circleElement, error);
                    }
                });
            }

            if(!isLegendOn){
                colourLegendElement.classList.add("d-none");
                // set leaf node colour to #999
                // Iterate through all leaf nodes and color them #999
                
            }else{
                colourLegendElement.classList.remove("d-none");
                
            }

            updateLeafNodeColors(isLegendOn);
        }

        round_decimals = function(){
            let rounding = $("#decimal-slider").val();
            $("#decimal-slider-value").text(rounding);
            DECIMAL_PLACES = rounding;
            redrawTree(); // Need to redraw the tree to update the svg text
        }


        branch_lengths_on_off = function(node){
            SHOW_BRANCH_LENGTHS = !SHOW_BRANCH_LENGTHS;
            $(".branch-length").css("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        });
        }
        
        let show_inner_node_labels = (node) => {
            SHOW_METADATA_IN_NAME = !SHOW_METADATA_IN_NAME
            $(".inner-node-label").css("visibility", () => {
                            if(!SHOW_METADATA_IN_NAME){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        });
        }


        scroll_legend_into_view = function(node,full_screen_btn, node_TreeData){
            
            if(node !== null){
                const x = Math.round(node_TreeData.scrollLeft+10);
                const y = Math.round(node_TreeData.scrollTop+10);

                // Skip if the movement is less than 5px (small)
                if (Math.abs(x - LAST_SCROLL_X) < 5 && Math.abs(y - LAST_SCROLL_Y) < 2) {
                    return;
                }

                LAST_SCROLL_X = x;
                LAST_SCROLL_Y = y;
             
                node.style.left=`${x}px`
                node.style.top=`${y}px`
                full_screen_btn.style.right = `-${node_TreeData.scrollLeft}px`
                full_screen_btn.style.top = `${node_TreeData.scrollTop}px`

            }else{
                console.error('No legend rendered skipping scroll_legend_into_view()')
            }    
        }

        reset_zoom_slider = function(){
            document.querySelector('#zoom_slider_value').textContent = 1
            document.querySelector('#zoom_slider').value = 1
        }    

        let select_deselect_nodes_by_field_value = (legend_node, column_index) => {
            const categoryName = legend_node.getAttribute('data-fieldvalue');
            const columnName = data_table.column(column_index).header().innerText.trim(); 
            //find indices of filtered data in a metadata table
            let getIndexes = () => {
                return data_table.rows((idx, data, node) => {
                    return data[column_index] === `${legend_node.getAttribute('data-fieldvalue')}`;
                }).indexes();
            };

            let indexes = getIndexes();

            
            let selected = legend_node.classList.contains('fw-bold') ? true : false
            
            

            let selected_node_ids = data_table.cells(indexes,0).data();

            if (selected_node_ids.length === 0) {
               
                Swal.fire({
                    title: "Selected Nodes Not Found in Metadata",
                    html: `The selected category <b>${categoryName}</b> in in column <b>${columnName}</b> contains samples are currently hidden.<br><br>Would you like to clear ALL metadata filters to select these nodes?`,
                    icon: "warning",
                    showCancelButton: true,
                    confirmButtonColor: "#3085d6",
                    cancelButtonColor: "#d33",
                    confirmButtonText: "Yes, clear filters"
                }).then((result) => {
                    if (result.isConfirmed) {
                        data_table.clear();
                        data_table.rows.add(Array.from(ORIGINAL_DATA.values())).draw();
                        $("td").addClass("editable");
                        $("td:not(:first-child)").attr("contenteditable", true);
                        
                        select_deselect_nodes_by_field_value(legend_node, column_index);
                    }
                });
                return; 
            }

            if(!selected){
                legend_node.classList.add('fw-bold');
            }else{
                legend_node.classList.remove('fw-bold');
            }
                

            for(var i = 0; i < selected_node_ids.length; i++) {
                let tree_node = document.querySelector( `[id='${selected_node_ids[i]}']`)
                let [ele, circle, text] = SelectedNodes.getNodeData(tree_node);

                if(!selected){
                    if(circle.dataset.oldfill){
                        circle.dataset.oldfill = circle.style.fill;
                    }
                    SelectedNodes.addNodes(text);
                }else{
                    SelectedNodes.unselectNode(text);
                }    
            }
            // Bring the terminal node into frame
            let lastId = selected_node_ids[selected_node_ids.length-1];
            terminal_node = document.querySelector(`[id="${lastId}"]`);
            if (terminal_node) {
                terminal_node.scrollIntoView({block: "center", inline: "center"})
            }else{
                console.warn(`Node with ID ${lastId} not found in DOM. Cannot scroll.`);
            }    
            SelectedNodes.drawSelectedNodes();
            
        }

        remove_selected_node = function(node_id){
            let trg_node = SelectedNodes.nodes.get(node_id);
            SelectedNodes.unselectNode(trg_node);
            SelectedNodes.drawSelectedNodes();
        }

        let original_data_blob = (headers) => {
            // Create a text string of the original data
            let output_text = new Array();
            output_text.push(headers.join("\t"))
            
            for(const [key, value] of ORIGINAL_DATA.entries()){
                output_text.push(value.join("\t"))
            }
            return output_text;
        };

        let filtered_data_blob = (headers) => {
            let output_text = new Array();
            output_text.push(headers.join("\t"))
            data_table.rows().data().each((value, index) => {
                output_text.push(value.join("\t"))
            });
            return output_text;
        }

        export_metadata_table = function(e){
            // Export updated metadata
            console.debug(e.id)
            if(!ORIGINAL_DATA){
                console.error("No contextual data imported yet");
                Swal.fire({
                    title: "Error",
                    text: "No metadata table imported yet. Please upload data first!",
                    icon: "error"
                    });
                return false;
            }
            let headers = Array.from(TABLE_HEADERS);
            headers.push("modified"); // Values track what have been modified however it is not in the original headers
            let output_text = null;
            let updated_metadata = null;
            if(e.id === "export-metadata-table"){
                output_text = original_data_blob(headers);
                updated_metadata = "FullClusterInfo.tsv";
            }else if(e.id === "export-metadata-view"){
                output_text = filtered_data_blob(headers);
                updated_metadata = "FilteredClusterInfo.tsv"
            }else{
                console.error("Unknown element specified for export of data.")
                return false;
            }

            const blob = new Blob([output_text.join("\n")], {type: "text/tsv"} );


            if(window.navigator.msSaveOrOpenBlob){
                // thank stackoverflow for this: https://stackoverflow.com/questions/3665115/how-to-create-a-file-in-memory-for-user-to-download-but-not-through-server
                window.navigator.msSaveBlob(blob, updated_metadata);
            }else{
                const elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = updated_metadata;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
                window.URL.revokeObjectURL(elem.href); // revoke object url as it wont be cleared till after the browser is closed otherwise
            }
            Swal.fire({
                    title: "Exported Metadata",
                    text: `Exported ${output_text.length-1} rows of metadata saved in ${updated_metadata}`,
                    icon: "info"
                    })
            return true;

        }

        //adapted from https://observablehq.com/@mbostock/saving-svg by Mike Bostock
        serialize2svg = function(svg) {
            const xmlns = "http://www.w3.org/2000/xmlns/";
            const xlinkns = "http://www.w3.org/1999/xlink";
            const svgns = "http://www.w3.org/2000/svg";
            //svg = svg.cloneNode(true);
                        
            const lgd = document.getElementById("colour-legend");
            const legend_width = lgd.clientWidth;

            const fragment = window.location.href + "#";
            const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);
            while (walker.nextNode()) {
            for (const attr of walker.currentNode.attributes) {
                if (attr.value.includes(fragment)) {
                    attr.value = attr.value.replace(fragment, "#");
                    }
                }
            }

            svg.setAttributeNS(xmlns, "xmlns", svgns);
            svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);

            // Clone style elements to add incorporate into the SVG file
            const css_export = document.createElement("defs")
            const link_style_sheet = document.createElement("link");
            link_style_sheet.setAttribute("href", "https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css");
            link_style_sheet.setAttribute("rel", "stylesheet");
            link_style_sheet.setAttribute("crossorigin", "anonymous");
            css_export.appendChild(link_style_sheet);
            svg.insertBefore(css_export, svg.firstChild);

            const tree_svg = svg.querySelector("#TreeSVG");
            const offset_safety_factor = 20;
            tree_svg.style.marginLeft = legend_width + offset_safety_factor;

            const serializer = new window.XMLSerializer;
            const xml_string = serializer.serializeToString(tree_svg); //we export tree_svg and not svg as pure svg does not support html elements such as legend
            return [new Blob([xml_string], {type: "image/svg+xml"}), xml_string];
        }



       
        export_tree_to_svg = function(event){
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }

            const versionMeta = document.querySelector('meta[name="version"]');
            const versionNumber = versionMeta.getAttribute('content');

            const date = new Date();
            let downloadLink = document.createElement("a");
            downloadLink.download = 'tree_snapshot_'+date.getDate()+'-'+
                (date.getMonth()+1)+'-'+date.getFullYear()+'_'+date.getHours()+'h.svg';
            let svg =  document.getElementById("TreeData").cloneNode(true)
            let svgElement = svg.querySelector("#TreeSVG");
            const currentViewBox = svgElement.getAttribute("viewBox");
            let [x, y, width, height] = currentViewBox.split(/[\s,]+/).map(Number);
            svgElement.setAttribute("viewBox", `${x} ${y-20} ${width} ${height}`);
            svgElement.style.fontFamily = "monospace";

            const versionText = document.createElementNS("http://www.w3.org/2000/svg", "text");
            versionText.textContent = `v${versionNumber}`;

            versionText.setAttribute("x", x + width - 10); // 10px from right edge
            versionText.setAttribute("y", y - 5);          
            versionText.setAttribute("fill", "#999999");
            versionText.setAttribute("font-size", "14px");
            versionText.setAttribute("font-family", "monospace");
            versionText.setAttribute("text-anchor", "end"); // Right-aligned sticking to right margin

            svgElement.appendChild(versionText);
                
        
            //remove duplicated leaf nodes text duplication for more accurate searches
            svg.querySelectorAll('g .tree-node').forEach(node => {
                text_nodes_leafs = node.querySelectorAll('text[class=""]')
                if(text_nodes_leafs.length === 2){
                    text_nodes_leafs[0].remove()
                }
            })

            svg.querySelector("#TreeSVG").style.overflow = "visible"
            const blob = serialize2svg(svg)[0];
            downloadLink.href = window.URL.createObjectURL(blob);
            console.log(window.URL.createObjectURL(blob))
            downloadLink.click(); //Trigger a click on the element
            downloadLink.remove();               
        }

        
        /*Adapted from https://gist.github.com/tatsuyasusukida/1261585e3422da5645a1cbb9cf8813d6 and https://zooper.pages.dev/articles/how-to-convert-a-svg-to-png-using-canvas*/
        export_tree_to_png = function(event){
          if (event) event.preventDefault();
            
          let svg =  document.getElementById("TreeSVG").cloneNode(true); 
          let legendOrigin = document.getElementById("colour-legend");
          let hasLegend = legendOrigin && !legendOrigin.classList.contains('d-none');
          svg.style.fontFamily = "monospace";

          let legendWidth = hasLegend ? legendOrigin.offsetWidth : 0;
          let legendHeight = hasLegend ? legendOrigin.offsetHeight : 0;

          let {x, y, width, height} = svg.viewBox.baseVal;
          let svg_width = width;
          let svg_height = height;
          
          let modified_width =  svg_width + (svg_width * 0.15);
          let modified_height =  svg_height// + (svg_height * 0.15);
         
          
          // Change the width of the svg element allowing for more of the viewbox to show up
          svg.setAttribute("width", modified_width)
          
          /* 
            Create a temporary svg expanding increasing the size of the final 
            canvas the elelment is rendered in. Having this seperate wrapper
            also allows for seperate modifications of the PNG before export allowing
            for translationst to be performed.
          */
          let wrapping_svg = d3.select("body")
            .append("svg")
            .attr("id", "temporary_svg")
            .attr("height", modified_height)
            .attr("width", modified_width)
            .append('g')
            .attr("id", "translation_element")
            .attr("height", modified_height)
            .attr("width", modified_width)
            .attr("viewBox", `${x} ${y} ${modified_width} ${modified_height}`)
           // .append(() => {
          //    return svg
          //})
          if (hasLegend) { //add legend if it exists to svg
            let legendClone = legendOrigin.cloneNode(true);
            const activeStyles = window.getComputedStyle(legendOrigin);
            legendClone.style.cssText = activeStyles.cssText;

            //replace bootstrap d-flex with classical flex
            legendClone.querySelectorAll('.d-flex').forEach(el => {
                el.style.display = "flex";
                el.style.alignItems = "center";
                el.style.padding = "4px";
            });

            legendClone.querySelectorAll('.text-center').forEach(el => {
                el.style.textAlign = "center";
                el.style.display = "block"; // Ensure it takes full width to allow centering
                el.style.width = "100%";
            });

            legendClone.querySelectorAll('.d-flex').forEach(el => el.style.display = "flex");

            // 3. Replace inputs with solid squares
            legendClone.querySelectorAll('input').forEach(el => {
                let square = document.createElement('div');
                square.style.cssText = "width:20px; height:20px; border:1px solid black; display:inline-block; flex-shrink:0;";
                square.style.backgroundColor = el.value;
                el.parentNode.replaceChild(square, el);
            });
            const fObject = wrapping_svg.append("foreignObject")
            .attr("x", 30) // Anchored to the top-left of the viewport
            .attr("y", 35)
            .attr("width", legendOrigin.offsetWidth) // Fixed width for the legend area
            .attr("height", legendOrigin.scrollHeight);

            // Add XHTML wrapper with minimal Bootstrap-mimicking styles
            const div = fObject.append("xhtml:div")
                .attr("xmlns", "http://www.w3.org/1999/xhtml")
                .attr("style", "background-color: white; border: 1px solid #ccc;");
            div.append(() => legendClone);;
           
          }

          wrapping_svg.append('g')
            .attr("id", "translation_element")
            .append(() => svg);

          
          //extract SVG element
          const svgData = new XMLSerializer().serializeToString(document.getElementById("temporary_svg"));
       
          //create canvas to the size of the SVG
          let canvas = document.createElement('canvas')
          canvas.width = modified_width;
          canvas.height = modified_height;
          
          //create SVG image element
          let img = new Image();
          img.src = "data:image/svg+xml;base64," + btoa(svgData);

          img.onload = function () { //must be inside this image onload event function due to async image load nature
              //render SVG image onto canvas element
              const versionMeta = document.querySelector('meta[name="version"]');
              const versionNumber = versionMeta.getAttribute('content');

              let ctx = canvas.getContext('2d');
              ctx.fillStyle = "white";
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              ctx.drawImage(img, 0,  0, modified_width, modified_height);

              ctx.font = "14px monospace";
              ctx.fillStyle = "#999999"; // Subtle grey
              ctx.textAlign = "right";   // Align text to the right edge
              ctx.textBaseline = "top";  // Align text to the top edge
              ctx.fillText(`v${versionNumber}`, canvas.width - 10, 5);
             
              //create PNG image from the canvas
              let pngUrl = canvas.toDataURL('image/png').replace('image/png', 'octet/stream');
              //create download link
              let downloadLink = document.createElement("a");
              downloadLink.download = 'tree_snapshot.png';
              downloadLink.href = pngUrl;
              downloadLink.click();
              downloadLink.remove();
          }
          
          // Remove temporary elements
          document.getElementById("temporary_svg").remove();


        }    

        tree_full_screen_mode = function(){
            if (document.fullscreenElement === null){
                document.querySelector('#TreeData').requestFullscreen()
            }else{
                document.exitFullscreen();  
            }    
            
        }

        metadata_full_screen_mode = function(){
            let clusterInfo = document.querySelector('#ClusterInfo');
            let metadata_panel = document.querySelector('#ClusterInfo>div')
            if (document.fullscreenElement === null){
                METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH = metadata_panel.style.height;
                clusterInfo.requestFullscreen();
                document.body.style.overflow = 'visible';
                metadata_panel.style.height = '100vh';
       
            }else{
                document.exitFullscreen();
                console.debug(METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH);
                metadata_panel.style.height = METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH;
            }            
        }

        
        document.addEventListener("DOMContentLoaded",()=>{
           /**
             * Handles dynamic layout adjustments when the #ClusterInfo section is shown or hidden.
             *
             * The code manages layout changes triggered by toggling the #ClusterInfo collapsible metadata panel 
             * (e.g., by clicking on the blue bar), ensuring proper height distribution among surrounding elements.
             *
             * When the panel is collapsed or expanded, it adjusts the height of:
             *  - #TreeData: the main tree visualization container
             *  - #control_panel: the left-side control panel
             *  - #SelectedNodes: the panel showing selected tree nodes (via max-height)
             *
             * This ensures that when the metadata panel is hidden, the freed vertical space is redistributed to 
             * other visible panels, allowing them to expand and fully utilize the viewport.
             *
             * It relies on inline styles and consistent height units (e.g., px) to compute and apply the new layout.
             * Designed to enhance UI responsiveness and usability when toggling metadata visibility.
             *
             */
            
            

            document.querySelector('#ClusterInfo').addEventListener('hidden.bs.collapse', function () {
                let heightMetaDiv = document.querySelector('#ClusterInfo>div').style.height
                let heightTreeDataDiv = document.querySelector('#TreeData').style.height
                let resizerHeight = document.querySelector('#resizer-bar').offsetHeight
                let unitMatchTree = heightTreeDataDiv.match(/.?(\w{1,2})$/)
                let unitMatchMeta = heightMetaDiv.match(/.?(\w{1,2})$/)
                let unitTree = unitMatchTree ? unitMatchTree[1] : null;
                let viewportHeight = window.visualViewport.height;
                let maxAllowedHeight = window.innerHeight - resizerHeight - 10;
                /*let unitMeta = unitMatchMeta ? unitMatchMeta[1] : null;
            
                // Calculate the equivalent pixel value from vh
                if(unitMeta === "vh"){
                    const viewportHeight = window.visualViewport.height-10;
                    heightMetaDiv = (parseFloat(heightMetaDiv) / 100) * viewportHeight;
                    unitMeta="px"
                }*/
                      
                if(unitTree !== null){
                    let calculatedHeight = parseFloat(heightTreeDataDiv) + parseFloat(heightMetaDiv)
                    let finalHeight = Math.min(calculatedHeight, maxAllowedHeight);
                    
                    document.querySelector('#TreeData').style.height= finalHeight +"px"
                    document.querySelector('#control_panel').style.height = finalHeight +"px"
                }else{
                    
                    document.querySelector('#TreeData').style.height=`${window.visualViewport.height-10}px`
                    document.querySelector('#control_panel').style.height=`${window.visualViewport.height-10}px`
                }
                    //document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
                adjustSelectedNodesHeight()
            }) 

            document.querySelector('#ClusterInfo').addEventListener('show.bs.collapse', function () {
                let heightMetaDiv = document.querySelector('#ClusterInfo>div').style.height
                let heightTreeDataDiv = document.querySelector('#TreeData').style.height

                let unitMatchTree = heightTreeDataDiv.match(/.?(\w{1,2})$/)
                let unitMatchMeta = heightMetaDiv.match(/.?(\w{1,2})$/)
                let unitTree = unitMatchTree ? unitMatchTree[1] : null;
                //let unitMeta = unitMatchMeta ? unitMatchMeta[1] : null;

                /*if(unitMeta === "vh"){
                    const viewportHeight = window.visualViewport.height;
                    heightMetaDiv = (parseFloat(heightMetaDiv) / 100) * viewportHeight;
                    unitMeta="px"
                }*/
          
                //let unit = heightTreeDataDiv.match(/.?(\w{1,2})$/)[1]
                document.querySelector('#TreeData').style.height= parseFloat(heightTreeDataDiv) - parseFloat(heightMetaDiv)+"px"
                document.querySelector('#control_panel').style.height = parseFloat(heightTreeDataDiv) - parseFloat(heightMetaDiv)+"px"
                //document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
                adjustSelectedNodesHeight()
            })

            //allows to bring back into view the control left panel if it obstructed by the metadata table if one moves mouse into the control panel area
            

            

    
        });    

        //run this code when all DOM and elements have been loaded
        window.addEventListener("load", function(){
            const controlPanel = document.querySelector('#control_panel');
            const clusterInfo = document.querySelector('#ClusterInfo');
            const ORIGINAL_CONTROL_PANEL_HEIGHT  = controlPanel.getBoundingClientRect().height
            const versionMeta = document.querySelector('meta[name="version"]');
    
            const versionNumber = versionMeta.getAttribute('content');
            const watermark = document.getElementById('version-watermark');
            watermark.textContent = `v${versionNumber}`;

            function adjustClusterInfoPanelHeight(controlPanel, clusterInfo) { 
                const resizerHeight = document.querySelector('#resizer-bar').offsetHeight;   
                // Calculate the desired height for the cluster info panel.
                let newHeight = window.innerHeight - ORIGINAL_CONTROL_PANEL_HEIGHT - resizerHeight - 4;
                // Define the minimum height as 10% of the viewport.
                const minHeightPercentage = 0.10;
                const tenPercentViewportHeight = window.innerHeight * minHeightPercentage;

                // If the calculated height is less than the minimum, use the minimum height instead.
                if (newHeight < tenPercentViewportHeight) {
                    newHeight = tenPercentViewportHeight;
                }

                // Set the height of the cluster info panel's inner div.
                clusterInfo.querySelector("div").style.height = `${Math.floor(newHeight)}px`;
            }

            adjustClusterInfoPanelHeight(controlPanel, clusterInfo)

            const ORIGINAL_METADATA_HIGHT  = clusterInfo.querySelector("div").style.height
            
            // Ths listener detecta when fullscreen mode ends and restores the layout dimensions to the original values captured on load. This is necessary as exiting fullscreen can cause the layout to resize in unexpected ways, and we want to ensure a consistent user experience by reverting to the known "safe" dimensions.
            document.addEventListener('fullscreenchange', () => {
                // If document.fullscreenElement is null, we have just EXITED fullscreen
                if (!document.fullscreenElement) {
                    console.debug("Exited fullscreen: Restoring layout dimensions.");
                    
                    // Force the layout back to the known "safe" dimensions captured on initial load
                    if(document.querySelector('#control_panel')){
                        document.querySelector('#control_panel').style.height = `${ORIGINAL_CONTROL_PANEL_HEIGHT}px`;
                    }
                    if(document.querySelector('#TreeData')){
                        document.querySelector('#TreeData').style.height = `${ORIGINAL_CONTROL_PANEL_HEIGHT}px`;
                    }
                    if(document.querySelector('#ClusterInfo>div')){
                        document.querySelector('#ClusterInfo>div').style.height = ORIGINAL_METADATA_HIGHT;
                    }
                    adjustSelectedNodesHeight();
                }
            });

            if (controlPanel && clusterInfo) {
                controlPanel.addEventListener('mouseenter', () => {  
                    const controlPanelRect = controlPanel.getBoundingClientRect();
                    const metadataRect = clusterInfo.getBoundingClientRect();
                    /*console.debug(`controlPanelRect=${JSON.stringify(controlPanelRect)}\n
                    metadataRect=${JSON.stringify(metadataRect)}\n
                    ORIGINAL_CONTROL_PANEL_HIGHT=${JSON.stringify(ORIGINAL_CONTROL_PANEL_HEIGHT)}`);
                    */

                    // Check for overlap
                
                    const overlap = controlPanelRect.height < ORIGINAL_CONTROL_PANEL_HEIGHT;

                    if (overlap) {
                        document.querySelector('#control_panel').style.height=`${ORIGINAL_CONTROL_PANEL_HEIGHT}px`;
                        document.querySelector('#TreeData').style.height=`${ORIGINAL_CONTROL_PANEL_HEIGHT}px`
                        document.querySelector('#ClusterInfo>div').style.height=ORIGINAL_METADATA_HIGHT;
                        adjustSelectedNodesHeight() 
                    }
                       
                });
            }
            
        
        });
        // Call once DOM is ready
        /*
        document.addEventListener("DOMContentLoaded", () => {
            initializeClusterInfoToggleBehavior();
        });*/


        clear_selected_nodes = function(){
            // Clear selected nodes and un-bold legend text
            SelectedNodes.deselectNodes(); // deselect nodes
            SelectedNodes.clearNodes();
            // a way to de colour all of these nodes probably exists
            $(".legend-element > .fw-bold").each((it, ele) => {
                ele.classList.remove("fw-bold");
            })

        }

        copy_ids_to_clipboard = function(){
            let text2copyArray=[]
            
            document.querySelectorAll('#SelectedNodes div>div:first-child').forEach(node => {
                console.debug(node.textContent)
                text2copyArray.push(node.textContent)
            })

            if(text2copyArray.length > 0){
                let text2copy = text2copyArray.join('\n');
                navigator.permissions.query({ name: "clipboard-write" }).then((result) => {
                    if (result.state === "granted" || result.state === "prompt") {
		                navigator.clipboard.writeText(text2copy)
                        Swal.fire({
                            html: `<p>Successfully copied ${text2copyArray.length} node IDs to the clipboard<br>Generate a text file with the ${text2copyArray.length} IDs?</p>`,
                            icon: "info",
                            showDenyButton: true,
                            showCancelButton: false,
                            confirmButtonText: 'Yes',
                            denyButtonText: 'No'
                        }).then( (result) => {
                            if (result.isConfirmed) {
                                let success_msg = `Copied ${text2copyArray.length} sample IDs to the clipboard`
                                console.debug(text2copy);
                                let file = new File(["\ufeff"+text2copy], 'selectedNodes.txt', {type: "text/plain:charset=UTF-8"})
                                //create a ObjectURL in order to download the created file
                                url = window.URL.createObjectURL(file);
                                let a = document.createElement("a");
                                a.style = "display: none";
                                a.href = url;
                                a.download = file.name;
                                a.click();
                                window.URL.revokeObjectURL(url);
                            }
                        });
                    }    
                   
                });

                
            }
            else{
                Swal.fire({
                    html: "<b>No nodes to copy and export!</b><p>Select tree node(s) first and try again</p>",
                    icon: "error"
                    });
                
            }            

        }

        vertical_div_resize = function(event){
            event.preventDefault()
            let cursor_pos_init = event.y
            const clusterInfo = document.querySelector('#ClusterInfo');
            metadata_panel = document.querySelector('#ClusterInfo>div')
            treeData_panel = document.querySelector('#TreeData')
            control_panel = document.querySelector('#control_panel')

            let metadata_panel_height_init = metadata_panel.getBoundingClientRect().height
            let treeData_panel_height_init = treeData_panel.getBoundingClientRect().height
            let control_panel_height_init = control_panel.getBoundingClientRect().height
            document.addEventListener('mousemove', resize, false)
            document.addEventListener('mouseup', stop_resize, false)

            //Only uncollapse if it was hidden and do not use bsCollapse.show(), the animation will conflict with the mouse move.
            if (!clusterInfo.classList.contains('show')) {
                clusterInfo.classList.add('show'); // Force the class on immediately with no animation
                metadata_panel.style.height = '0px'; // Ensure element starts at 0 height for correct math
            }

            function resize(event){
                event.stopPropagation();
                const dy = event.y - cursor_pos_init  
                metadata_panel.style.height = metadata_panel_height_init - dy+'px'
                treeData_panel.style.height  = treeData_panel_height_init + dy +'px'
                control_panel.style.height = control_panel_height_init + dy +'px'
            }
            function stop_resize(event){
                document.removeEventListener('mousemove', resize)
                document.querySelector('#SelectedNodes').style.Height = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            
                

            }   
            
        }
        document.addEventListener('mouseup',(event)=>{
                document.removeEventListener('mousemove', vertical_div_resize,false)
                adjustSelectedNodesHeight() 
        })
    

    //The Bootstrap dropdown-menu position absolute css is not working and menu is obscured by other divs
    //This fixes the issue as we do not want to modify original BS code
    dropdownmenufix = function(){
        document.querySelector('.dropdown-menu').style['position']="fixed"
    }

    /**
     * Enables dragging of the #colour-legend div by mouse.
     * 
     * When the user clicks and holds the mouse down on the legend div, 
     * this function tracks mouse movements and moves the legend accordingly,
     * preserving the initial grab offset within the div to prevent jumpiness.
     * 
     * It also accounts for the width of a left-side control panel (#control_panel)
     * by offsetting the drag position, except when the document is in fullscreen mode,
     * in which case the offset is ignored.
     * 
     * @param {MouseEvent} event - The initial mouse down event that starts dragging.
     *                             It provides the starting coordinates of the drag.
     * 
     
    * **/
    dragDivByMouse = function(event) {
        const legend_div = document.querySelector('#colour-legend');
        const control_panel_div = document.querySelector("#control_panel");
        const treeDataContainer = document.querySelector('#TreeData');

        //Current SVG TreeData scroll positions to adjust for scrolling during drag
        const scrollY = treeDataContainer.scrollTop;
        const scrollX = treeDataContainer.scrollLeft;
        

        // Get bounding box of the legend
        const rect = legend_div.getBoundingClientRect();

        // Calculate initial grab offset (mouse position within the div)
        const grabOffsetX = event.clientX - rect.left;
        const grabOffsetY = event.clientY - rect.top;


        const tree = document.querySelector('#TreeData');

        // Store control panel width
        let controlPanelOffset = control_panel_div.offsetWidth;
        // Override offset if document is in fullscreen mode
        if (document.fullscreen === true) {
            controlPanelOffset = 0;
        }

        let isDown = true;

        function move(e) {
            if (!isDown) return;
            e.preventDefault();

            // Calculate new position, accounting for grab offset and control panel width
            const newLeft = e.clientX - grabOffsetX - controlPanelOffset + scrollX;
            const newTop = e.clientY - grabOffsetY + scrollY;

            legend_div.style.left = newLeft + "px";
            legend_div.style.top = newTop + "px";
        }

        function stopDrag() {
            isDown = false;
            document.removeEventListener('mousemove', move, true);
            document.removeEventListener('mouseup', stopDrag, true);
        }

        // Attach listeners
        document.addEventListener('mousemove', move, true);
        document.addEventListener('mouseup', stopDrag, true);
    };



    </script>
</head>
    <body>
        <div id="top-section-container" class="container-fluid m-0">
            <div class="row no-wrap"> <!-- id="TreeSelections" style=""-->
                <div id="control_panel" class="col-2 border border-primary px-1 position-relative">
                    <div id="tree_menu_buttons" class="row m-0">
                                <div class="d-flex flex-row align-items-stretch p-0 text-left mt-1">
                                    <button class="h-100 flex-grow-1 me-1 mb-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Select a newick file" onclick="document.getElementById('tree-selector').click();" name="newick" id="tree-upload-button">
                                        <i class="bi bi-upload me-1"></i>Newick <i class="bi bi-tree ml-1"></i>
                                    </button>
                                    <input  type="file" id="tree-selector" name="tree-selector" accept=".nwk, .newick, .treefile" hidden> 
                                    <button class="h-100 flex-grow-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Select a tab delimited metadata file" onclick="document.getElementById('metadata-selector').click();" 
                                        id="metadata-selector-input" name="metadata-selector-input">
                                        <i class="bi bi-upload me-1"></i>Meta <i class="bi bi-file-spreadsheet ml-1"></i>
                                    </button>
                                    <input type="file"  id="metadata-selector" 
                                    name="metadata-selector" accept=".tsv, .tab" hidden>
                                </div>
                                <!--button type="button" class="btn-sm btn-primary w-100 text-break mb-1 mt-1" data-toggle="tooltip" data-placement="top" 
                                    title="Clear filters applied to the metadata table." name="ResetTable" id="reset-table-button">Clear filters</button-->                                
                                
                                <div class="d-flex flex-row align-items-center p-0 text-left flex-wrap gap-1 mt-1 mb-1">
                                    <button class="flex-grow-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top"  
                                        title="Copy selected node IDs to your clipboard to paste into another application and optionally generate a text file" onclick="copy_ids_to_clipboard()" name="CopyIDs" id="copy-ids-button">
                                        <i class="bi bi-clipboard m-1"></i>IDs
                                    </button>
                                    <button type="button" class="flex-grow-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Export the tree to SVG." onclick="export_tree_to_svg(event)" id="export-tree-to-svg">
                                        <i class="bi bi-download m-1"></i> SVG
                                    </button>
                                    <button type="button" class="flex-grow-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Export the tree to PNG." onclick="export_tree_to_png(event)" id="export-tree-to-png">
                                        <i class="bi bi-download m-1"></i> PNG
                                    </button>
                                </div>
                                <div class="dropdown p-0">
                                    <button class="w-100 flex-grow-1 mb-1 btn-sm btn-primary dropdown-toggle text-wrap" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        <i class="bi bi-download me-1"></i>Export Meta Table
                                    </button>
                                    <ul class="dropdown-menu">
                                        <li><a id="export-metadata-view" data-toggle="tooltip" data-placement="top" title="Export the currently selected filtered metadata." 
                                        class="dropdown-item text-wrap flex-grow-1 me-1 btn-sm btn-primary text-break mb-1" onclick="export_metadata_table(this)" id="export-metadata-view">
                                            <i class="bi bi-download me-1"></i>Export Filtered Table
                                            </a>
                                        </li>
                                        <li><a id="export-metadata-table" data-toggle="tooltip" data-placement="top" title="Export the complete unfiltered metadata." 
                                            class="dropdown-item text-wrap flex-grow-1 me-1 btn-sm btn-primary text-break mb-1" onclick="export_metadata_table(this)" id="export-metadata-view">
                                                <i class="bi bi-download me-1"></i>Export Full Table
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <!--Tree layout slider-->
                                <div class="d-flex flex-row align-items-center p-0 text-left">
                                    <button data-toggle="tooltip" data-placement="top" title="Redraw the entire tree undoing any changes." 
                                    class="btn-sm btn-primary w-100 h-100 text-break me-1" name="RedrawTree" id="redraw-tree-button"><i class="bi bi-pencil-square"></i> Redraw Tree</button>
                                    <button data-toggle="tooltip" data-placement="top" title="Bring the tree back into focus" class="btn-sm btn-primary w-100 h-100" name="ResetTree" id="ResetTree"><i class="bi bi-eyeglasses"></i> Refocus tree</button>
                                </div>
                                <div class="flex flex-col p-0">
                                    <!--Zoom slider-->
                                    <div data-toggle="tooltip" data-placement="top" title="Zoom in or out on the tree" 
                                    class="d-flex align-items-center justify-content-between p-1">
                                        <small class="text-start text-break" for="zoom_slider" 
                                        class="form-label" style="width:30%">Zoom</small>
                                        <div class="px-2" style="width:60%">
                                            <input type="range" class="w-100 form-range align-middle"  id="zoom_slider" onchange="zoom_tree()" value="1" min="0.5" max="5" step="0.5">
                                        </div>
                                        <div class="fw-bold text-start" style="width:10%">
                                            <small id="zoom_slider_value">1</small><small>x</small>
                                        </div>    
                                    </div>  
                                    <!-- Decimal rounding -->
                                    <div data-toggle="tooltip" data-placement="top" title="Specify the number of decimals to display." 
                                    class="d-flex align-items-center justify-content-between p-1">
                                        <small class="text-start text-break" for="decimal_rounding" 
                                        class="form-label" style="width:30%"># of decimals</small>
                                        <div class="px-2" style="width:60%">
                                            <input type="range" class="w-100 form-range align-middle"  id="decimal-slider" onchange="round_decimals()" value=1 min="0" max="10" step="1">
                                        </div>
                                        <div class="fw-bold text-start" style="width:10%">
                                            <small id="decimal-slider-value">1</small>
                                        </div>    
                                    </div>  

                                    <!--Slider for adjusting line thickness-->
                                    <div data-toggle="tooltip" data-placement="top" title="Adjust line thickness" 
                                    class="d-flex align-items-center justify-content-between p-1">
                                        <small class="text-start text-break" for="zoom_slider" 
                                        class="form-label" style="width:30%">Line Weight</small>
                                        <div class="px-2" style="width:60%">
                                            <input type="range" class="w-100 form-range align-middle"  id="line-thickness" onchange="lineThickness(this)" value="2.0" min="0.5" max="10.0" step="0.5">
                                        </div>
                                        <div class="fw-bold fs-6 text-start" style="width:10%">
                                            <small id="line-thickness-value">2.0</small>
                                        </div>    
                                    </div> 
                                </div>

                                <div id="dropdown_tree_types" onclick="dropdownmenufix()" class="d-flex flex-wrap p-0 dropdown mb-1">
                                    <button id="tree_dropdown_menu"  class="btn btn-primary btn-sm dropdown-toggle w-100 text-wrap" type="button" data-toggle="tooltip" data-placement="top" title="List of fields to colour nodes by.">
                                        Select a tree layout</button>
                                </div> 
                                <!--button class="btn-sm btn-primary w-100 text-break mb-1" onclick="switchTreeType()" name="SwitchTree" id="switch-tree">Switch Tree</button-->   
                                <div id="legend-box" class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn the legend on or off">
                                    <small  class="flex-grow-1" for="legend_toggle">Legend</small>
                                    <input onchange="legend_on_off(this)" id="legend_toggle" 
                                    checked type="checkbox" data-toggle="toggle" data-onstyle="primary" data-size="sm">
                                </div> 
                                <div class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn branch lengths on or off" >
                                    <small data-toggle="tooltip" data-placement="top" title="Turn branch lengths on or off" class="flex-grow-1" for="legend_toggle">Branch lengths</small>
                                    <input onchange="branch_lengths_on_off(this)" id="branch_lengths_toggle" 
                                    checked type="checkbox" data-toggle="toggle" data-placement="top" title="Turn branch lengths on or off" data-onstyle="primary" data-size="sm">
                                </div>  
                                <div class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn inner node labels on and off" >
                                    <small data-toggle="tooltip" data-placement="top" title="Turn inner node labels on and off" class="flex-grow-1" for="legend_toggle">Inner node labels</small>
                                    <input onchange="show_inner_node_labels(this)" id="inner_node_labels_toggle" 
                                    type="checkbox" data-toggle="toggle" data-placement="top" title="Turn inner node labels on and off" data-onstyle="primary" data-size="sm">
                                </div>  
                                <div id="dropdown_legend"  class="d-flex flex-wrap p-0 dropdown mb-1">
                                    <button id="legend_dropdown_button" class="btn btn-danger btn-sm dropdown-toggle w-100 text-wrap" type="button" data-toggle="tooltip" data-placement="top" title="List of fields to colour nodes by.">
                                        Awaiting metadata</button>
                                </div>
                                <div id="dropdown_append_metadata2nodes"  class="d-flex flex-wrap p-0 dropdown mb-1">
                                    <button id="metadata_fields_dropdown_button" class="btn btn-danger btn-sm dropdown-toggle w-100 text-wrap" type="button" data-toggle="tooltip" 
                                    data-placement="top" data-bs-auto-close="outside" title="List of fields to colour nodes by">
                                        Add metadata to nodes</button>
                                </div>

                                    
                                <div class="d-flex flex-row align-items-center p-0 text-left m-0 flex-wrap gap-1">
                                    <!-- 1) Filter data -->
                                    <button
                                      id="metadata-search-button"
                                      name="SearchMetadata"
                                      class="btn btn-sm btn-primary d-inline-flex align-items-center justify-content-center flex-grow-1 m-0"
                                      data-bs-toggle="tooltip"
                                      data-bs-placement="top"
                                      title="Filter metadata for selected nodes">
                                      <i class="bi bi-search me-2 icon-image"></i>
                                      Filter data
                                    </button>
                               
                                    <button
                                      id="clear-selected-nodes"
                                      name="ClearSelectedNodes"
                                      class="btn btn-sm btn-primary d-inline-flex align-items-center justify-content-center flex-grow-1"
                                      data-bs-toggle="tooltip"
                                      data-bs-placement="top"
                                      title="Clear/Deselect all selected nodes in the panel and tree."
                                      onclick="clear_selected_nodes()">
                                      <i class="bi bi-x-square me-2"></i>
                                      Deselect nodes
                                    </button>
                                </div>  
                    </div> 
            
                    <div data-toggle="tooltip" data-placement="top" 
                        title="Selected nodes on the tree will show up here." 
                        class="col mt-1 border border-primary p-1 w-100 Tree inline-block-child scrollbar-window" 
                        id="SelectedNodes" style="height: 15vh;">
                        <div class="d-flex h-100 text-center text-uppercase text-center">
                            <small class="align-self-center w-100">Selected Nodes</small>
                        </div>        
                    </div>
                </div> 


                <div class="position-relative p-0 bg-white col-10 Tree inline-block-child scrollbar-window" 
                onscroll="scroll_legend_into_view(document.querySelector('#colour-legend'), document.querySelector('#tree_fullscreen_btn'), this)"
                id="TreeData">
                        
                        <div id="tree-splash" class="w-100 h-100 fs-2 d-flex justify-content-center align-items-center" style="height:50vh;"><i class="bi bi-tree"></i> Your tree will show up here when loaded!</div>
                        
                        <div id="colour-legend"
                        class="d-none p-1 position-absolute border border-primary text-break Tree inline-block-child scrollbar-window" 
                        style="top:0px; left:0px; resize: both; max-height:100%; background-color: rgba(255, 255, 255, 0.9)">   
                        </div>
                        <div id="version-watermark" style="
                            position: fixed; 
                            top: 0px; 
                            margin-right: 30px;
                            right: 10px; 
                            z-index: 1000; 
                            font-family: monospace; 
                            font-weight: bold;
                            font-size: 14px; 
                            color: #999;
                        "></div>
                        <i style="position:absolute; top:0; right: 0; cursor: pointer; color:blue; margin-right:1px" id="tree_fullscreen_btn" 
                        onclick="tree_full_screen_mode()" class="d-flex fs-5 bi-arrow-up-right-square"></i>
                        
                </div> 

            </div>
                
                
        </div>
        
        <div id="resizer-bar" class="row m-0" style="background-color: #0d6efd; 
        position: relative;">
                <a  href="#" data-bs-toggle="collapse" data-bs-target="#ClusterInfo"></a>
                <div class="p-0" onmousedown="vertical_div_resize(event)" 
                    style="position:absolute; cursor: ns-resize; 
                    box-shadow: 1px 1px 1px 1px rgba(0,0,0,.8); border-radius: 3px; left:50%; 
                    background-color: #dc3545; width:50px; height:10px; z-index: 2;
                    left: calc(50% - 25px); top: calc(50% - 5px);">
                </div>
        </div>
        
        <div id="ClusterInfo" class="row bg-white collapse show border border-primary w-100 m-0">
                <div class="col-12 p-0">
                    <div id="table-splash" class="fs-2 d-flex justify-content-center align-items-center h-100" ><i class="bi bi-file-spreadsheet"></i> Your metadata will go here when loaded!</div>
                    <table id="metadata" class="w-100 display nowrap overflow-scroll" >
                    </table>
                    </div>    

                </div>            
          <!-- Need to have the legend be scrollable and situated under the selected nodes-->  
        </div> 
        <div id="TestSubTree"></div> 
        

    
    </body>
</html>
