<!DOCTYPE html>
<html>
<head>
    <style>
        .inline-block-child {
            display: inline-block;
        }

        .scrollbar-window{
            overflow: auto;
            /*overflow-x: scroll;*/
            /*height: 200px;*/
        }

        input[type="file"] {
            /* Hide the button in boot strap*/
            display: none;
        }

        
        .input-group-text:hover {
            filter: brightness(80%);
        }

        .legend-element:hover {
            filter: opacity(0.5);
            cursor: pointer;
        }


        .scale-bar {
            cursor: move;
            visibility: visible;
        }

        @keyframes spin {
            0% {
                transform: rotate(0);
            }
            25% {
                transform: rotate(-0.05turn);
            }

            50% {
                transform: rotate(0);
            }

            75% {
                transform: rotate(0.05turn);
            }

            100% {
                transform: translateY(0);
            }
        }

        @keyframes  updown {
            0% {
                transform: translateY(-10%);
            }

            50% {
                transform: translateY(10%);
            }

            100% {
                transform: translateY(-10%);
            }
        }

        .icon-spin {
            animation: spin 1s linear infinite;
        }

        .icon-jump {
            animation: updown 1s ease infinite
        }


        /* dataTables Search input box */
    
        .dataTables_filter {
            position: relative;
            margin-right: 24px;
        }
        .dataTables_wrapper .dataTables_filter input{
            border-radius: 20px !important;
            margin-top: 1px;
        }
    
        .dataTables_filter input {
            width: 250px;
            height: 26px;
            background: #fcfcfc;
            box-shadow: 0 0 3px #ccc, 0 10px 15px #ebebeb inset;
            text-indent: 10px;
        }
    
        .dataTables_filter .fa-search {
            position: absolute;
            top: 10px;
            left: auto;
            right: 10px;
        }



    </style>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Random colour library for creating some nice highlighted trees  https://github.com/davidmerfield/randomColor   -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/randomcolor/0.6.1/randomColor.min.js" integrity="sha512-vPeZ7JCboHcfpqSx5ZD+/jpEhS4JpXxfz9orSvAPPj0EKUVShU2tgy7XkU+oujBJKnWmu4hU7r9MMQNWPfXsYw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.js"></script>
    <!-- Below switching to tidy tree 0.5.1 as the dev broke 0.5.0 -->

    <script rel="stylesheet" type="text/javascript" href="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    
    <!--JQuery Beautiful Data Tables-->
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.11.3/css/jquery.dataTables.min.css">
    <script type="text/javascript" src="https://cdn.datatables.net/1.11.3/js/jquery.dataTables.min.js"></script>


    <!--Bootstrap 5 library elements-->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.5/font/bootstrap-icons.css">
    
    
    <!--toggle buttons by https://palcarazm.github.io/bootstrap5-toggle/ -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/css/bootstrap5-toggle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap5-toggle@5.0.4/js/bootstrap5-toggle.jquery.min.js"></script>

    <!-- Sweet Alerts 2 -->
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!--Colour distances calculation library at https://github.com/color-js/color.js-->
    <script src="https://colorjs.io/dist/color.global.js"></script>

    

    <script type="text/javascript">

        const __DEADBEEF__ = 0xDEADBEEF;
        const __DEADFOOD__ = 0xDEADF00D;
        //var test_newick = "(((B:1.000000,A:1.000000):3.0,C:4.000000):4.0,D:8.000000);"
        //var test_newick = "((BGIOSIFCE006902.1_ORYSA:0.652945[&&NHX:S=ORYSA],(At4g19560.1_ARATH:0.566484[&&NHX:S=ARATH],(At4g19600.1_ARATH:0.229647[&&NHX:S=ARATH],At5g45190.1_ARATH:0.149569[&&NHX:S=ARATH]):0.109796[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.283052[&&NHX:S=ARATH:SIS=100:D=Y:B=100]):0.930921[&&NHX:S=Magnoliophyta:D=N:B=100],((((((((((((CCNK_HUMAN:0.001351[&&NHX:S=HUMAN],CCNK_F3_PANTR:0.001588[&&NHX:S=PANTR]):0.009317[&&NHX:S=Homo/Pan/Gorilla_group:D=N:B=100],CCNK_MACMU:0.01227[&&NHX:S=MACMU]):0.020339[&&NHX:S=Catarrhini:D=N:B=100],(CCNK_BOVIN:0.049478[&&NHX:S=BOVIN],CCNK_CANFA:0.076883[&&NHX:S=CANFA]):0.026972[&&NHX:S=Laurasiatheria:D=N:B=97]):0.01376[&&NHX:S=Eutheria:D=N:B=62],(Ccnk_MOUSE:0.018183[&&NHX:S=MOUSE],LOC500715_RAT:0.02728[&&NHX:S=RAT]):0.054247[&&NHX:S=Murinae:D=N:B=100]):0.087752[&&NHX:S=Eutheria:D=N:B=65],CCNK_MONDO:0.069457[&&NHX:S=MONDO]):0.053263[&&NHX:S=Theria:D=N:B=83],NP_001026380_CHICK:0.085022[&&NHX:S=CHICK]):0.059401[&&NHX:S=Amniota:D=N:B=80],CCNK_XENTR:0.175799[&&NHX:S=XENTR]):0.075577[&&NHX:S=Tetrapoda:D=N:B=97],((si_dkey-60a16_F2_BRARE:0.143195[&&NHX:S=BRARE],(CCNK_TETNG:0.142629[&&NHX:S=TETNG],CCNK_F2_GASAC:0.115749[&&NHX:S=GASAC]):0.130837[&&NHX:S=Percomorpha:D=N:B=100]):0.077038[&&NHX:S=Clupeocephala:D=N:B=95],ENSGACT00000017400_GASAC:0.40355[&&NHX:S=GASAC]):0.058401[&&NHX:S=Clupeocephala:SIS=33:D=Y:B=13]):0.233994[&&NHX:S=Euteleostomi:D=N:B=18],(ENSCINT00000017473_CIOIN:0[&&NHX:S=CIOIN],ENSCINT00000026852_CIOIN:0.002343[&&NHX:S=CIOIN]):0.481407[&&NHX:S=CIOIN:SIS=100:D=Y:B=100]):0.090892[&&NHX:S=Chordata:D=N:B=98],((CycK-RA_DROME:0.17719[&&NHX:S=DROME],dper_GLEANR_8777_caf1_DROPE:0.174477[&&NHX:S=DROPE]):0.199588[&&NHX:S=Sophophora:D=N:B=100],(AAEL013531-RA_AEDAE:0.214131[&&NHX:S=AEDAE],XP_317464_ANOGA:0.204436[&&NHX:S=ANOGA]):0.178396[&&NHX:S=Culicidae:D=N:B=100]):0.293157[&&NHX:S=Diptera:D=N:B=100]):0.104694[&&NHX:S=Coelomata:D=N:B=98],Smp_130980_SCHMA:0.624197[&&NHX:S=SCHMA]):0.041513[&&NHX:S=Bilateria:D=N:B=84],(WBGene00009650_CAEEL:0.186775[&&NHX:S=CAEEL],(CBG04574_CAEBR:0.21279[&&NHX:S=CAEBR],cr01.sctg48.wum.67.1_CAERE:0.192611[&&NHX:S=CAERE]):0.076335[&&NHX:S=Caenorhabditis:D=N:B=86]):1.18006[&&NHX:S=Caenorhabditis:D=N:B=86]):0.311276[&&NHX:S=Bilateria:D=N:B=84])[&&NHX:S=Eukaryota:D=N:B=0];"
        const TREE = __DEADBEEF__;
        // the '= __DEADFOOD__' is an expression to find and replace and inline tsv string e.g. 'head1\thead2\nv1\tv2\n's
        const DATA = __DEADFOOD__;
        const DEBUG = false;
        const TREE_OFFSET = 100;
        var METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH = null; //before changing to full screen mode save the current size of the metadata table
        var NEWICK = null;
        var tree_root = null;
        var METADATA = null;
        var TABLE_HEADERS = null;
        var data_table = null;
        var query_table = null;
        var ORIGINAL_DATA = null;
        var ORIGINAL_VIEW_BOX = null;
        var ORIGINAL_WIDTH_SVG = 0;  
        var LAST_MOVE_X = 0;
        var LAST_MOVE_Y = 0;
        var SHOW_BRANCH_LENGTHS = true;
        var SHOW_METADATA_IN_NAME = false;
        var LINE_THICKNESS = 2.0;  
        var TREE_VAL = "Dendrogram"; // sets default tree style to draw
        var PREVIOUS_UNCOLLAPSED_TREE_HEIGHT = 0; //previous tree hight uncollapsed useful when tree branches collapse
        /*
        As we are not passing the tree object into the d3 tree drawing functions
        we need this to be a global constant sadly. Unless we perform a larger refactor.
        */
        var TREE_ULTRAMETRIC_P = false; 

        var collapse_subtree = false; // can think of another way to signal state without our larger refactor 
        var focused_element = null; // Focused element to have its colour reset
        var RADIUS_INCREASED = false;
        var MENU_CREATED = false;
        const colour_legend = new Array;
        const default_color = "#999";
        const clicked_color = "blue";
        const ID_FIELD = 0;
        // Refactoring selected nodes to make it easier to update the legend and selected nodes on dom changes
        const right_mouse = 3;
        const center_mouse = 2;
        const left_mouse = 1;
        const CIRCLE_SIZE_SELECTED = 6;
        const INNER_NODE_SIZE = 4;
        const LEAF_NODE_SIZE = 6;
        var DECIMAL_PLACES = 1;
        const DISTANCE_LABEL_OFFSET = 5.2


        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TREE FUNCTIONS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // These are messy due to the way in which they were created, and there has not been time
        // to refactor them yet sadly.

        function addDisplayDistance(d, rd){

            let next_rd = null;
            if(TREE_ULTRAMETRIC_P){
                // Collapsing currently does not work due to the subtracting at 
                // each step
                d.display_dist = rd - d.data.d
                next_rd = d.display_dist
            }else{
                d.display_dist = d.data.max_length     
                next_rd = d.data.max_length
            }

            if (d.children) {
                d.children.forEach(d => addDisplayDistance(d, next_rd))
            }
        }

        function maxLength(d) {
            return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
        }

        const addTreeDisplayDistance = (tree_root) => {
            tree_root.display_dist = tree_root.data.max_length
            if(TREE_ULTRAMETRIC_P){
                // Get the root to leaf length for display
                tree_root.display_dist = maxLength(tree_root)
            }

            tree_root.children.forEach(d => addDisplayDistance(tree_root, tree_root.display_dist))

        }

        function enableVerticalElementDrag(targetGroup) {
            let isDragging = false;
            let startY = 0;
            let initialTransformY = 0;
            let isSelected = false;

            // Make it focusable and style cursor
            targetGroup
                .attr("tabindex", 0)

            // Handle selection and mouse dragging
            targetGroup.on("mousedown", function (event) {
                event.stopPropagation(); // Prevent body from deselecting
                isSelected = true;
                targetGroup.node().focus(); // Give focus so keyboard works
                isDragging = true;
                startY = event.clientY;
                initialTransformY = getCurrentY();
                event.preventDefault();
            });

            // Deselect when clicking elsewhere
            d3.select("body").on("mousedown", function () {
                isSelected = false;
                targetGroup.node().blur(); // Remove focus
            });

            // Keyboard interaction only when selected
            targetGroup.on("keydown", function (event) {
                if (!isSelected) return;
                const currentY = getCurrentY();
                const step = 5;
                if (event.key === "ArrowUp") {
                setTransform(currentY - step);
                event.preventDefault();
                } else if (event.key === "ArrowDown") {
                setTransform(currentY + step);
                event.preventDefault();
                }
            });

            // Global mouse movement tracking for dragging
            d3.select(window)
                .on("mousemove.scaleBar", function (event) {
                if (isDragging) {
                    const deltaY = event.clientY - startY;
                    setTransform(initialTransformY + deltaY);
                }
                })
                .on("mouseup.scaleBar", function () {
                isDragging = false;
                });

            // Helpers
            function getCurrentY() {
                const transform = targetGroup.attr("transform");
                const match = transform && transform.match(/translate\(([^,]+),\s*([^)]+)\)/);
                return match ? parseFloat(match[2]) : 0;
            }

            function setTransform(y) {
                targetGroup.attr("transform", `translate(0, ${y})`);
            }
        }



        function drawScale(svg, length, height, max_length, root){
            /**
             * Draws a scale bar in a dendrogram or phylogenetic tree visualization,
             * indicating tree distances or heights. Supports both ultrametric and non-ultrametric trees.
             * The scale bar includes major and minor ticks, and dynamically adjusts to the tree layout.
             *
             * @function drawScale
             * @param {d3.Selection} svg - SVG element where the scale bar will be drawn.
             * @param {number} length - Length of the scale bar in pixels.
             * @param {number} height - Vertical position of the scale bar from the top of the SVG in pixels.
             * @param {number} max_length - Maximum length of the tree in the same units as the Newick file (e.g., number of alleles).
             * @param {d3.HierarchyNode} root - A D3 hierarchy node, typically created using `d3.hierarchy(data)`. 
             *   Should include a `data.max_length` field representing the starting cumulative distance from the root,
             *   which is used in non-ultrametric trees to adjust the scale bar labels.
             *
             * @returns {void}
             *
             * @example
             * // Assuming you have a D3 SVG selection and tree metadata:
             * drawScale(svg, 200, 30, 1.2, treeRootNode);
             *
             * @remarks
             * - Automatically appends a toggle switch UI to enable/disable the scale bar.
             * - Minor ticks are drawn at 0.1 unit intervals by default.
             * - Major ticks are drawn in red with corresponding numerical labels.
             * - For ultrametric trees, the scale bar is rendered in reverse (right to left).

             * @notes
             * scale bar is slightly difficult to add, as the svg viewport dat only shows up AFTER rendering
             */
            
            // --- Input Validation ---
            try {
                if (!svg || typeof svg.append !== 'function' || svg.empty()) {
                    throw new Error("Invalid 'svg' parameter: expected a D3 selection.");
                }
                if (typeof length !== 'number' || isNaN(length) || length <= 0) {
                    throw new Error("Invalid 'length' parameter: must be a positive number.");
                }
                if (typeof height !== 'number' || isNaN(height) || height < 0) {
                    throw new Error("Invalid 'height' parameter: must be a non-negative number.");
                }
                if (typeof max_length !== 'number' || isNaN(max_length) || max_length <= 0) {
                    throw new Error("Invalid 'max_length' parameter: must be a positive number.");
                }
                if (!root || typeof root !== 'object' || !root.data || typeof root.data.max_length !== 'number') {
                    throw new Error("Invalid 'root' parameter: must be an object with 'data.max_length' number.");
                }
            } catch (error) {
                console.error("drawScale() failed due to invalid input:", error.message);
                return; // Exit early to avoid rendering with bad input
            }
            const scaleBarGroup = svg.append("g").attr("id", "scale-bar-group") //group all svg path elements under single group
            enableVerticalElementDrag(scaleBarGroup); //enables vertical drag of the scale bar

            let scale_bar_menu = `<div id="scale-bar-menu" class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn scalebar on/off">
                <small  class="flex-grow-1" for="scale_bar_toggle">Scale Bar</small>
                <input id="scale-bar-toggle" onchange="scale_bar_on_off(this)" id="scale_bar_toggle" checked type="checkbox" data-toggle="toggle" data-onstyle="primary" data-size="sm">
            </div>`

            $(scale_bar_menu).insertBefore("#legend-box")
            $("#scale-bar-toggle").bootstrapToggle()
            $("#scale-bar").css("visibility", "visible");

            let scale = `M 0 -${height} H ${length}` //defines the length of the scale object
            let stroke_width = 5
            let bar_opacity = 0.4


            scaleBarGroup.append("path")
            .attr("d", scale)
            .attr("stroke-width", stroke_width)
            .attr("stroke-opacity", bar_opacity)
            .attr("stroke", "#000")
            .attr("fill-opacity", 1)
            .attr("class", "scale-bar")

            //let test_inc =  max_length / 10 // 10 was chosen randomly as I mock something up
            let increase_factor = length / max_length
            
            let n_minor_divisions = 0, num_major_ticks = 0; 
                factors=Array(10).fill(0).map((i,index)=>{return Math.pow(10,index)}); //generate array of factor from 1 to 1e10
                factor_selected = 1; n_minor_divisions_step = 0.1;
    
            //given a max length of the tree, understand the tree total length decimal point precision if it is less than 1.
            //if less than zero find a factor that will covert it to integer space via multiplication (i.e for 0.53 multiply by 10 = 5.3)
            //then identify the major and minor number of divisions valid for ultramertic trees
            //from factors array find a scaling factor in the number space
            for (var i=0; i<factors.length;i++){
                if(Math.trunc(max_length*factors[i]) > 0){
                    num_major_ticks = Math.trunc(max_length*factors[i])
                    n_minor_divisions = Math.round(max_length*factors[i]/n_minor_divisions_step) //using default step of 0.1
                    factor_selected = factors[i]

                    // If only 1 major tick, try using the next higher factor
                    if (num_major_ticks === 1 && i + 1 < factors.length) {
                        factor_selected = factors[i + 1];
                        num_major_ticks = Math.trunc(max_length * factor_selected);
                        n_minor_divisions = Math.round(max_length * factor_selected / n_minor_divisions_step);
                    }
                    break
    
                }   

            }
            
            let test_inc_sub = length/n_minor_divisions //minor division size in tree scale units
            let minor_ticks_coordinates_px = [];
            
            //draw minor scale ticks first going from left to right (-->) 
            for(let i=0; i <=n_minor_divisions; i+=1){
                scaleBarGroup.append("path")
                .attr("d", `M ${i*test_inc_sub} -${height - stroke_width} V -${height}`)
                .attr("fill-opacity", 1)
                .attr("stroke", "#000")
                .attr("class", "scale-bar")
                .attr("stroke-width","1")
                minor_ticks_coordinates_px.push(i*test_inc_sub)   
            }
            
            
            
            /**
             * @remarks
             * Renders major tick marks and numeric labels along the scale bar
             *
             * - For **non-ultrametric trees** such as ML (max likelihood) and phylogenetic trees (`TREE_ULTRAMETRIC_P` is `false`):
             *   - tick marks and distances progress from left to right (→), representing
             *     cumulative evolutionary distance from the root to leaves rendered
             *     in red.
             *   - Uses `root.data.max_length` as a starting offset, which may be non-zero
             *     in ML trees or rooted trees inferred from input data (i.e. newick file).
             *   - Major tick text labels are generated at regular intervals (defined by `test_inc`) rendered above each major tick
             *
             * - For **ultrametric trees** (`TREE_ULTRAMETRIC_P` is `true`):
             *   - tick marks and labels progress from right to left (←), reflecting the cummulative
             *     distance/height from leaves to the root.
             *   - Major ticks coordinates are extracted from reversed minor tick coordinates,
             *     with every 10th tick selected.
             *   - Each tick is labeled with the corresponding tree distance, scaled
             *     by the selected factor to maintain appropriate precision.
             *
             * In both cases, red tick marks represent major divisions, and text labels
             * above them denote tree distance values based on `DECIMAL_PLACES` selected value defaulting to 1.
             */
            
            if(!TREE_ULTRAMETRIC_P){
                //phylogenetic tree showing cumulative distance from root to the leaf (-->)
                let distance_root_start = root.data.max_length //root node might start not at zero in ML phylo tree
                let major_ticks_coordinates_px = minor_ticks_coordinates_px.filter((c,index) => index % 10 === 0);

                for(let i=0; i <= num_major_ticks; i+=1 ){
                    //use minor divisions minor tick units and covert it to a major tick unit plus the root start distance
                    let d = Number(max_length/n_minor_divisions*10*i + distance_root_start).toFixed(DECIMAL_PLACES)
                    //major divisions
                    scaleBarGroup.append("path")
                    //.attr("d", `M ${i * increase_factor} -${height - stroke_width}  V -${height + stroke_width}`)
                    .attr("d", `M ${major_ticks_coordinates_px[i]} -${height - stroke_width} V -${height + stroke_width}`)
                    .attr("fill-opacity", 1)
                    .attr("stroke", "red")
                    .attr("class", "scale-bar")
                    .attr("stroke-width","3")
                    
                    //major divisions text
                    scaleBarGroup.append("text")
                    //.attr("dx", i * increase_factor)
                    .attr("dx",major_ticks_coordinates_px[i])
                    .attr("stroke", "#000")
                    .attr("fill", "#000")
                    .attr("stroke-width", 1)
                    .attr("fill-opacity", 1)
                    .attr("dy", -height - 5)
                    .text( d )
                    .attr("font-size", 14)
                    .attr("class", "scale-bar")
                }
            }else{
                //the tree is ultrametric showing a distance bar from leaf to the root that is from right to left (<--)
                let major_ticks_coordinates_px = minor_ticks_coordinates_px.reverse().filter((c,index) => index % 10 === 0);
                for(let i=0; i <= num_major_ticks; i+=1){
                    //add major ticks in RED
                    scaleBarGroup.append("path")
                    .attr("d", `M ${major_ticks_coordinates_px[i]} -${height - stroke_width} V -${height + stroke_width}`)
                    .attr("fill-opacity", 1)
                    .attr("stroke", "red")
                    .attr("class", "scale-bar")
                    .attr("stroke-width","2")

                    //add major ticks text
                    scaleBarGroup.append("text")
                    .attr("dx", major_ticks_coordinates_px[i]) //length-(i*increase_factor))
                    .attr("stroke", "#000")
                    .attr("fill", "#000")
                    .attr("stroke-width", 1)
                    .attr("fill-opacity", 1)
                    .attr("dy", -height - 5)
                    .text( i/factor_selected )
                    .attr("font-size", 14)
                    .attr("class", "scale-bar")
                }

            }    

        }


        const cladeogram_chart = (data) => {
            // Made with lost of help from: https://observablehq.com/d/6c52fee38fb28b2f
                $("#branch_lengths_toggle").bootstrapToggle('off')
                SHOW_BRANCH_LENGTHS = false;
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width);
    
                //var width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30; // updated for viewing
                const marginLeft = 40;

                const label_safety_factor = 300; 
                const inner_radius = width - label_safety_factor;


                function maxLength(d) {
                    return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
                }

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
                
                
                const leaves_in_tree = root.leaves();
                const pixels_per_label = 15;
                
                const dx = 20;

                const dy = inner_radius / root.height;

                function setDistance(d, y0, k, dy) {
                    // From the tree of life code
                    d.distance = inner_radius - (d.height * dy)
                    if (d.children){
                        d.children.forEach(d => setDistance(d, y0, k, dy));
                    } 
                }

                setDistance(root, root.data.d = 0, (inner_radius / maxLength(root)), dy) // Third value is a scaling factor

                
                tree = d3.cluster()
                            .nodeSize([dx, dy])
                            .separation( (a, b) => { return 1;}) // Can pass in a custom function to alter distance between labels, 1 means all labels are spaced the same distance
                
                diagonal = (d) => {
                    // https://www.w3.org/TR/SVG/paths.html#PathElement for path movements meanings
                    // https://yqnn.github.io/svg-path-editor/ for planning paths
                    return `M${d.source.distance},${d.source.x} V${d.target.x} H${d.target.distance}`

                };
                
                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width) //makes sure all tree nodes are within view
                    .attr("style", `width:100%; height: auto; font: 10px sans-serif; user-select: auto;`)
                
                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}"); 


                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");


                function update(event, source) {
                    console.log("590")
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                    const links = root.links();

                    // Compute the new tree layout...
                    tree(root);

                    let left = root;
                    let right = root;
                    
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });


                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition()
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [0, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        //.attr("transform", d => `translate(${d.distance},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(d.data.leaf){
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        }) 
                        .on("mousedown", (event, d) => {
                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);
                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", d => !d.data.leaf ? INNER_NODE_SIZE : LEAF_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                        .attr("fill", d => !d.data.leaf ? "#555" : "#999")               
                        .attr("stroke-width", 10);
                    
                    // Add branch length to all inner nodes
                    nodeEnter.append("text")
                        .text((d) => {
                            if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                            }})
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        .attr("dx", (d) => { 
                            let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                            return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 14)
                        .attr("font-size", 12);
                    
                    nodeEnter.append("text")
                        // dx the 12 corresponds to a safety metric to add some space between nodes, no children, dx is 0 to align leaves to inner nodes
                        // Below two lines allow for inner nodes to show up
                        .attr("dx", d => !d.data.leaf ? 0 : inner_radius - d.distance + 12) 
                        .attr("dy", d => !d.data.leaf  ? -8 : 0) 
                        .attr("x", d => !d.data.leaf ? -10 : 6)
                        .attr("font-size", 12)
                        .attr("text-anchor", d => !d.data.leaf ? "end" : "start")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .text(d => d.data.meta ? d.data.name ? `${d.data.name}-${d.data.meta}` : d.data.meta : d.data.name )
                        .clone(true).lower()
                        .attr("stroke", "white");
                    
                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.distance},${d.x})`) // aligns the text to the nodes
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)
                        .attr("d", diagonal);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", diagonal);

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", diagonal);

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
                }

            // Do the first update to the initial configuration of the tree — where a number of nodes
            // are open (arbitrarily selected as the root, plus nodes with 7 letters).
            root.x0 = dy / 2;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            });
            
            addTreeDisplayDistance(root)
            update(null, root);
            
            return svg.node();
        };


        const dendrogram_chart = (data) => {
                // Made with lost of help from: https://observablehq.com/d/6c52fee38fb28b2f
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width);
                //var width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30; // updated for viewing
                const marginLeft = 40;

                let label_safety_factor = 300; 
                const inner_radius = width - label_safety_factor;

                function setDistance(d, y0, k) {
                    // From the tree of life code
                    d.distance = (y0 += d.data.d) * k;
                    if (d.children) d.children.forEach(d => setDistance(d, y0, k));
                }



                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));

                let max_length = maxLength(root)
                setDistance(root, root.data.d = 0, (inner_radius / max_length)) // Third value is a scaling factor

                const leaves_in_tree = root.leaves();
                const pixels_per_label = 15;
                                
                const dx = 20;
                const root_node_height = dx * 0.5;
                //const dy = (width - marginRight - marginLeft) / (1 + root.height);
                const dy = inner_radius / root.height;
                // Test Scale drawing

                tree = d3.cluster()
                            .nodeSize([dx, dy])
                            .separation( (a, b) => { return 1;}) // Can pass in a custom function to alter distance between labels, 1 means all labels are spaced the same distance


                diagonal = (d) => {
                    // https://www.w3.org/TR/SVG/paths.html#PathElement for path movements meanings
                    return `M${d.source.distance},${d.source.x} L${d.source.distance},${d.target.x} L${d.target.distance},${d.target.x}`
                };
                
                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width + 20) //makes sure all tree nodes are within view
                    .attr("style", `width:100%; height: auto; font: 10px sans-serif; user-select: auto;`) 

                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");    
                
                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");
                
                function showLinkExtension(d, show=true) {
                        const dest = show ? inner_radius : d.target.distance;
                        const path = d3.path();
                        path.moveTo(d.target.distance, d.target.x);
                        path.lineTo(dest, d.target.x);
                        return path.toString();
                }

                let below_root = 0; 
                function update(event, source) {
                    console.log("Performing tree update")
                    // Recalculate tree lengths on collapse
                    let max_length = maxLength(root)
                    setDistance(root, root.data.d = 0, (inner_radius / max_length)) // Third value is a scaling factor


                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                    const links = root.links();

                    // Compute the new tree layout.
                    // Converting tree to cluster may solve our conundrum...
                    tree(root);
                    
                    svg.selectAll(".extension-node-links").remove();
                    

                    const linkExtension = svg.append("g") // Would probably save rendering if this was tied to the "entered nodes"
                            .attr("class", "extension-node-links")
                            .attr("fill", "none")
                            .attr("stroke", "#000")
                            .attr("stroke-opacity", 0.5)
                            .attr("stroke-dasharray", "4")
                            .selectAll("path")
                            .data(root.links().filter(d => d.target.data.leaf ))
                            .join("path")
                            .each(function(d) { d.target.linkExtensionNode = this; })
                            .attr("d", (d) => showLinkExtension(d, true)); // Shows lines to link
                    
                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });
                    
                    
                    //calculate a tree height
                    const newTreeHeight = right.x - left.x + marginTop + marginBottom
                    if (newTreeHeight > PREVIOUS_UNCOLLAPSED_TREE_HEIGHT ){
                        PREVIOUS_UNCOLLAPSED_TREE_HEIGHT = newTreeHeight
                    }

                    function updateScaleBarPosition(newTreeHeight) {
                        d3.select("#scale-bar-group")
                            .transition()
                            .duration(750) // Smooth transition
                            .attr("transform", `translate(0, ${newTreeHeight})`);
                    }
                    updateScaleBarPosition(PREVIOUS_UNCOLLAPSED_TREE_HEIGHT - newTreeHeight)



                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition()
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [0, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(d.data.leaf){
                                // count nodes below the root to set offset height for the scale
                                if(d.x > -root_node_height){ 
                                    below_root++
                                }
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        })
                        .on("mousedown", (event, d) => {

                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants();
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);

                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", d => !d.data.leaf ? INNER_NODE_SIZE : LEAF_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                        .attr("fill", d => !d.data.leaf ? "#555" : "#999")
                        .attr("stroke-width", 10);                    

                    // Add branch length to all inner nodes
                    nodeEnter.append("text")
                        .text((d) => {
                                if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                    return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                                }
                            })
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        .attr("dx", (d) => { 
                                let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                                return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 14)
                        .attr("font-size", 12);


                    nodeEnter.append("text")
                        // dx the 12 corresponds to a safety metric to add some space between nodes, no children, dx is 0 to align leaves to inner nodes
                        // Below two lines allow for inner nodes to show up
                        .attr("dx", d => !d.data.leaf ? 0 : inner_radius - d.distance + 12) 
                        .attr("dy", d => !d.data.leaf ? -8 : 0) 
                        .attr("x", d => !d.data.leaf ? -10 : 6)
                        .attr("font-size", 12)
                        .attr("text-anchor", d => !d.data.leaf ? "end" : "start")
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .text(d => d.data.meta ? d.data.name ? `${d.data.name}-${d.data.meta}` : d.data.meta : d.data.name )
                        .clone(true).lower()
                        .attr("stroke", "white");
                    
                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.distance},${d.x})`) // aligns the text to the nodes
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)
                        .attr("d", diagonal);

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", diagonal);

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", diagonal);

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
            }

            // Do the first update to the initial configuration of the tree — where a number of nodes
            // are open (arbitrarily selected as the root, plus nodes with 7 letters).
            root.x0 = dy / 2;
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
            d.id = i;
            d._children = d.children;
            });

            addTreeDisplayDistance(root)
            update(null, root);
            
            //! This math is not working out for all general cases :(
            /* 
                Formula for getting the scale bar at the top is
                
                (dx * number of leaves in the tree) - (number of leaves below root * dx)
            */
            if(below_root > 1){
                // Just one value is likely the root, and it needs to be ignored in its offset
                below_root--
            }
            
            if(!TREE_ULTRAMETRIC_P){
                max_length = maxLength(root)
            }else{
                max_length = root.display_dist
            }
            //let display_width = parseInt(ele_style.width) - label_safety_factor
            drawScale(gNode, inner_radius, (dx * leaves_in_tree.length) - (below_root*dx)-5, max_length, root)

            return svg.node();
        };


        const dendrogram_circle = (data) => {
            // Made with lots of help from: https://observablehq.com/d/6c52fee38fb28b2f
            var ele = document.getElementById("TreeData");
            var ele_style = window.getComputedStyle(ele);
            
            const width = parseInt(ele_style.width);
            const height = width;
            const outerRadius = width / 2; 
            const innerRadius = outerRadius - 170;
            const decimal_places = 4;
            const sc_to_radians = Math.PI / 180;

            const root = d3.hierarchy(data);
            root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
            addTreeDisplayDistance(root)
            
            const dx = 20; 
            const dy = outerRadius;
    
            function linkStep(startAngle, startRadius, endAngle, endRadius) {
                const c0 = Math.cos(startAngle = (startAngle - 90) / 180 * Math.PI);
                const s0 = Math.sin(startAngle);
                const c1 = Math.cos(endAngle = (endAngle - 90) / 180 * Math.PI); 
                const s1 = Math.sin(endAngle); 
                
                return "M" + startRadius * c0 + "," + startRadius * s0
                    + (endAngle === startAngle ? "" : "A" + startRadius + "," + startRadius + " 0 0 " + (endAngle > startAngle ? 1 : 0) + " " + startRadius * c1 + "," + startRadius * s1)
                    + " L" + endRadius * c1 + "," + endRadius * s1;
            }
            
            function setRadius(d, y0, k) {
                
                d.radius = (y0 += d.data.d) * k;
                if (d.children) d.children.forEach(d => setRadius(d, y0, k));
            }

            function linkVariable(d) {
                return linkStep(d.source.x, d.source.radius, d.target.x, d.target.radius);
            }

            function maxLength(d) {
                return d.data.d + (d.children ? d3.max(d.children, maxLength) : 0);
            }

            function linkConstant(d) {
                return linkStep(d.source.x, d.source.y, d.target.x, d.target.y);
            }

            function linkExtensionVariable(d) {
                return linkStep(d.target.x, d.target.radius, d.target.x, innerRadius);
            }

            function linkExtensionConstant(d) {
                return linkStep(d.target.x, d.target.y, d.target.x, innerRadius);
            }

            tree = d3.cluster()
                .size([360, innerRadius])
                .separation((a, b) => 1);

            const svg = d3.create("svg")
                .attr("id", "TreeSVG")
                .attr("viewBox", [0, 0, width, height])
                .attr("font-family", "sans-serif")
                .attr("font-size", 10)
                .attr("style", `width:100%; height: auto; font: 10px sans-serif; user-select: auto;`);
            
            svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");  

            const gNode = svg.append("g")
                .attr("cursor", "pointer")
                .attr("pointer-events", "all")
                .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
            
            const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS)
                    .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
            
            root.data.d = 0
            const max_len = innerRadius / maxLength(root)
            setRadius(root, root.data.d, max_len);

            function translate_points(d){

                let x = Math.cos((d.x - 90) * sc_to_radians) * d.radius
                let y = Math.sin((d.x - 90) * sc_to_radians) * d.radius;
                let output = `rotate(${d.x - 90}) translate(${d.radius},0)`
                return output
            }

            function translate_text(d){
                let new_rad = innerRadius - d.radius + 6
                if(!d.data.leaf){
                    new_rad = d.radius
                }
                

                
                let x = Math.cos((d.x - 90) * sc_to_radians) * new_rad;
                let y = Math.sin((d.x - 90) * sc_to_radians) * new_rad;

                let rot_val = d.x - 90;
                if(x < 0){
                    rot_val = d.x + 90;
                }
                d.x0 = x;
                d.y0 = y;
                let output = `translate(${x}, ${y}) rotate(${rot_val})`
                return output
            }
            
            
            function update(event, source){
                console.log("1156")

                const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                const nodes = root.descendants().reverse(); // Might be able to replace with the recurse tree function for speed up
                const links = root.links();
                tree(root)

                svg.selectAll(".extension-node-links").remove();

                const linkExtension = svg.append("g")
                    .attr("class", "extension-node-links")
                    .attr("fill", "none")
                    .attr("stroke", "#000")
                    .attr("stroke-opacity", 0.25)
                    .attr("stroke-dasharray", "4")
                    .selectAll("path")
                    .data(root.links().filter(d => d.target.data.leaf ))
                    .join("path")
                    .each(function(d) { d.target.linkExtensionNode = this; })
                    //.attr("d", linkExtensionConstant); // linkExtension constant can be passed in to align all branches to labels
                    .attr("d", (d) => linkExtensionVariable(d))
                    // Added to move points over
                    .attr("transform", `translate(${outerRadius}, ${outerRadius})`);
                
                let left = root;
                let right = root;
                root.eachBefore(node => {
                    if (node.x < left.x) left = node;
                    if (node.x > right.x) right = node;
                });

                ORIGINAL_WIDTH_SVG=width
                const transition = svg.transition()
                    .duration(duration)
                    .attr("height", height)
                    .attr("viewBox", [0, 0, width, height])
                    .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                const node = gNode.selectAll("g:not(#scale-bar-group)")
                    .data(nodes, d => d.id);

                const nodeEnter = node.enter().append("g")
                    .attr("transform", translate_points)
                    // Transform statement below can be used to re-orient leaves at the cost of mis-aligning them on collapse
                    //.attr("transform", d => `rotate(${d.x - 90}) translate(${d.radius},0)${d.x < 180 ? "" : " rotate(180)"}`)
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0)
                    .attr("id", (d) => {
                        if(d.data.name){
                            return d.data.name;
                        }
                    })
                    .attr("class", (d) => {
                        if(d.data.leaf){
                            return "tree-node leaf-node";
                        }
                        return "tree-node inner-node";
                    })
                    .on("mousedown", (event, d) => {

                        d.children = d.children ? null : d._children;
                        if(event.which == left_mouse){
                            NodeDropDownMenu(event, d, () => {
                                let updated_p = false;
                                updated_p = update(event, d);
                                if(updated_p){
                                    let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                    let uncollapsed_descendants_length = 1;
                                    // The length of the uncollapsed descendants is greater than one on uncollapse
                                    if(descendants.length > uncollapsed_descendants_length){
                                        for(const item of descendants){
                                            let name = item.data.name;
                                            if(name !== "" && SelectedNodes.nodes.has(name)){
                                                SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                SelectedNodes.setSelectedColours(text, circle);
                                            }
                                        }
                                    }
                                }
                            });
                        }
                });

                nodeEnter.append("circle")
                    .attr("r", d => d.data.leaf ? LEAF_NODE_SIZE : INNER_NODE_SIZE) // size 6 for leaf nodes and 4 for inner nodes
                    .attr("fill", d => d.data.leaf ? "#999" : "#555")
                    .attr("stroke-width", 10);

                nodeEnter.append("text")
                    .text((d) => {
                        if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                            return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                        }})
                    .attr("class", "branch-length")
                    .style("visibility", () => {
                        if(!SHOW_BRANCH_LENGTHS){
                            return "hidden"
                        }else{
                            return "visible"
                        }
                    })
                    .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        //.attr("position", "relative")
                    .attr("dx", (d) => { 
                        let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                        return `${-val.length + 1}pt`;
                    })
                    .attr("transform", (d) => {
                        return ""
                    })
                    .attr("dy", 14)
                    .attr("font-size", "12");
                
                nodeEnter.append("text")
                    .attr("dy", d => !d.data.leaf ? -8 : 0) // dx being in a different cord system seems to be causing issues...
                    .attr("dx", (d) => {
                        let hyp = 0 
                        if(d.data.leaf){
                            hyp = innerRadius - d.radius + 6;
                        }else{
                            hyp = d.data.d - 10;
                        }
                        return hyp}) // labels are not bein moved to the correct pos when redrawn
                    .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                    .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                    .text(d => d.data.meta ? d.data.name ? `${d.data.name}-${d.data.meta}` : d.data.meta : d.data.name )
                    .clone(true).lower()
                    .attr("font-size", "12")
                    .attr("stroke-linejoin", "round")
                    .attr("stroke", "white");
                    

                // Getting spontatnous errors in redraw
                // get new position
                const nodeUpdate = node.merge(nodeEnter)
                    .transition(transition)
                    .attr("transform", translate_points) // aligns the text to the nodes
                    .attr("fill-opacity", 1)
                    .attr("stroke-opacity", 1);
                

                const nodeExit = node.exit().transition(transition).remove()
                    .attr("transform", translate_points) // aligns the text to the nodes
                    .attr("fill-opacity", 0)
                    .attr("stroke-opacity", 0);
                
                // Update the links…
                const link = gLink.selectAll("path")
                    .data(links, d => d.target.id)
                    .attr("d", linkVariable);
                
                const linkEnter = link.enter().append("path")
                                    .attr("d", linkVariable);

                link.merge(linkEnter).transition(transition)
                        .attr("d", linkVariable);

                // Transition exiting nodes to the parent's new position.
                // TODO see if transition can be added it makes the whole flow smoother
                link.exit().remove(); // Removing the transition got rid of path errors

                // Stash the old positions for transition.
                root.eachBefore(d => {
                    d.x0 = d.x;
                    d.y0 = d.y;
                });
                return true;
            }
            
            root.x0 = root.x
            root.y0 = 0;
            root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
            });

            
            addTreeDisplayDistance(root)
            update(null, root);

            
            return svg.node();
        };

        const tidytree_chart = (data) => {
                // Specify the charts’ dimensions. The height is variable, depending on the layout.

                $("#branch_lengths_toggle").bootstrapToggle('off')
                SHOW_BRANCH_LENGTHS = false;
                var ele = document.getElementById("TreeData");
                var ele_style = window.getComputedStyle(ele);
                const width = parseInt(ele_style.width);
    

                
                //const width = window.innerWidth;
                const marginTop = 40;
                const marginRight = 10;
                const marginBottom = 30;
                const marginLeft = 40;

                // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
                // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
                // “bottom”, in the data domain. The width of a column is based on the tree’s height.
                const root = d3.hierarchy(data);
                root.sort((a, b) => b.height - a.height || d3.ascending(a.id, b.id));
                const dx = 20;
                const dy = (width - marginRight - marginLeft) / (1 + root.height);

                // Define the tree layout and the shape for links.
                tree = d3.tree().nodeSize([dx, dy]);
                diagonal = d3.linkHorizontal().x(d => d.y).y(d => d.x);
                
                // Create the SVG container, a layer for the links and a layer for the nodes.
                const svg = d3.create("svg")
                    .attr("id", "TreeSVG")
                    .attr("width", width + 20) //makes sure all tree nodes are within view
                    .attr("height", dx)
                    .attr("style", `width:${width}px; height: auto; font: 10px sans-serif; user-select: auto;`)

                
                svg.append("defs").append("style").attr("type", "text/css").text("svg text {cursor: text}");   

                const gLink = svg.append("g")
                    .attr("fill", "none")
                    .attr("stroke", "#555")
                    .attr("stroke-opacity", 0.8)
                    .attr("class", "adjustable-line")
                    .attr("stroke-width", LINE_THICKNESS);

                const gNode = svg.append("g")
                    .attr("cursor", "pointer")
                    .attr("pointer-events", "all");
                

                function update(event, source) {
                    console.log("1394")
                    const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
                    const nodes = root.descendants().reverse();
                    const links = root.links();

                    // Compute the new tree layout.
                    // Converting tree to cluster may solve our conundrum...
                    tree(root);

                    let left = root;
                    let right = root;
                    root.eachBefore(node => {
                        if (node.x < left.x) left = node;
                        if (node.x > right.x) right = node;
                    });


                    ORIGINAL_WIDTH_SVG=width
                    const height = right.x - left.x + marginTop + marginBottom;
                    const transition = svg.transition()
                        .duration(duration)
                        .attr("height", height)
                        .attr("viewBox", [0, left.x - marginTop, width, height])
                        .tween("resize", window.ResizeObserver ? null : () => () => svg.dispatch("toggle"));

                    // Update the nodes…
                    const node = gNode.selectAll("g:not(#scale-bar-group)")
                        .data(nodes, d => d.id);

                    // Enter any new nodes at the parent's previous position.
                    const nodeEnter = node.enter().append("g")
                        .attr("transform", d => `translate(${source.y0},${source.x0})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0)
                        .attr("id", (d) => {
                            if(d.data.name){
                                return d.data.name;
                            }
                        })
                        .attr("class", (d) => {
                            if(!d.children){
                                return "tree-node leaf-node";
                            }
                            return "tree-node inner-node";
                        })
                        .on("mousedown", (event, d) => {
                            d.children = d.children ? null : d._children;
                            if(event.which == left_mouse){
                                NodeDropDownMenu(event, d, () => {
                                    if(update(event, d)){
                                        let descendants = d.descendants(); // TODO the d3 leaves may be too slow, recurseTree better
                                        let uncollapsed_descendants_length = 1;
                                        // The length of the uncollapsed descendants is greater than one on uncollapse
                                        if(descendants.length > uncollapsed_descendants_length){
                                            for(const item of descendants){
                                                let name = item.data.name;
                                                if(name !== "" && SelectedNodes.nodes.has(name)){
                                                    SelectedNodes.nodes.set(name, $(`#TreeSVG [id='${name}']`)[0]); // TODO query all nodes at once
                                                    let [parent, circle, text] = SelectedNodes.getNodeData(SelectedNodes.nodes.get(name));
                                                    SelectedNodes.setSelectedColours(text, circle);

                                                }
                                            }
                                        }
                                    }
                                });
                            }
                        });

                    nodeEnter.append("circle")
                        .attr("r", d => d.data.leaf ? LEAF_NODE_SIZE : INNER_NODE_SIZE)
                        .attr("fill", d => d.data.leaf ? "#555" : "#999")
                        .attr("stroke-width", 10);

                    nodeEnter.append("text") // TODO can do this with if statement and recurse over them all may be a bit slower but more mem friednly
                        .text((d) => {
                            if(!d.data.leaf || !TREE_ULTRAMETRIC_P){
                                return Number((d.display_dist).toFixed(DECIMAL_PLACES))
                            }})
                        .attr("class", "branch-length")
                        .style("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        })
                        .attr("text-anchor", d => d.parent === null ? "start" : "end")
                        //.attr("position", "relative")
                        .attr("dx", (d) => { 
                            let val = Number((d.data.d).toFixed(DECIMAL_PLACES)).toString(); 
                            return `${-val.length + 1}pt`;
                        })
                        .attr("dy", 18)
                        .attr("font-size", "12");


                    nodeEnter.append("text")
                        .attr("dy", d => !d.data.leaf ? -6 : 0) 
                        .attr("x", d => !d.data.leaf ? -6 : 6)
                        .style("visibility", d => d.data.leaf ? "" : SHOW_METADATA_IN_NAME ? "visible" : "hidden")
                        .attr("class", d => d.data.leaf ? "" : "inner-node-label")
                        .text(d => d.data.meta ? d.data.name ? `${d.data.name}-${d.data.meta}` : d.data.meta : d.data.name )
                        .clone(true).lower()
                        .attr("stroke-linejoin", "round")
                        .attr("stroke-width", 3)
                        .attr("stroke", "white")
                        .attr("font-size", "12");
                    

                    // Transition nodes to their new position.
                    const nodeUpdate = node.merge(nodeEnter).transition(transition)
                        .attr("transform", d => `translate(${d.y},${d.x})`)
                        .attr("fill-opacity", 1)
                        .attr("stroke-opacity", 1);

                    // Transition exiting nodes to the parent's new position.
                    const nodeExit = node.exit().transition(transition).remove()
                        .attr("transform", d => `translate(${source.y},${source.x})`)
                        .attr("fill-opacity", 0)
                        .attr("stroke-opacity", 0);

                    // Update the links…
                    const link = gLink.selectAll("path")
                        .data(links, d => d.target.id)

                    // Enter any new links at the parent's previous position.
                    const linkEnter = link.enter().append("path")
                                        .attr("d", d => {
                                            const o = {x: source.x0, y: source.y0};
                                            return diagonal({source: o, target: o});
                                        });

                    link.merge(linkEnter).transition(transition)
                            .attr("d", diagonal);

                    // Transition exiting nodes to the parent's new position.
                    link.exit().transition(transition).remove()
                        .attr("d", d => {
                            const o = {x: source.x, y: source.y};
                            return diagonal({source: o, target: o});
                        });

                    // Stash the old positions for transition.
                    root.eachBefore(d => {
                        d.x0 = d.x;
                        d.y0 = d.y;
                    });
                    return true;
                }

                // Do the first update to the initial configuration of the tree — where a number of nodes
                // are open (arbitrarily selected as the root, plus nodes with 7 letters).
                root.x0 = dy / 2;
                root.y0 = 0;
                root.descendants().forEach((d, i) => {
                d.id = i;
                d._children = d.children;
                });
                
                addTreeDisplayDistance(root)
                update(null, root);
                
                return svg.node();

        }

        const TREE_SWITCH = new Map([
            ["Dendrogram", dendrogram_chart], 
            ["TidyTree", tidytree_chart], 
            ["Radial Dendrogram", dendrogram_circle], 
            ["Cladeogram", cladeogram_chart]]); // key value pairs map to switch between tree views


        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ End of tree definitions ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        // Class for selected nodes
        class SelectedNodes {
            static nodes = new Map();
            static #circle_pos = 1;
            static #name_pos = 3;
            static #circle_size_selected = LEAF_NODE_SIZE * 1.5;
            static #circle_size_default = LEAF_NODE_SIZE;
            static #default_color = "#999";
            static #clicked_color = "blue";
            static #svg_parent = "g";
            static selection_id = "#SelectedNodes";

            static getDefaultColour(){
                return SelectedNodes.#default_color;
            }

            static getSelectedColour(){
                return SelectedNodes.#clicked_color
            }

            static getCirclePos(){
                return SelectedNodes.#circle_pos;
            }

            static getNamePos(){
                return SelectedNodes.#circle_pos;
            }

            static clearNodes(){
                SelectedNodes.nodes.clear();
            }

            static setSelectedColours(text, circle){
                text.style.fontWeight = "bold";
                text.style.fill = "black";
                if(!circle.dataset.oldfill && circle.style.fill != SelectedNodes.#default_color){
                    circle.dataset.oldfill = circle.style.fill
                }
                circle.style.fill = SelectedNodes.#clicked_color;
                circle.setAttribute("r", SelectedNodes.#circle_size_selected);
            }

            static deSelectedColours(text, circle){
                text.style.fontWeight = "normal";
                text.style.fill = "black";
                if(circle.dataset.oldfill){
                    circle.style.fill = circle.dataset.oldfill;
                    if(circle.dataset.oldfill === SelectedNodes.#default_color){
                        delete circle.dataset.oldfill
                    }
                    
                }else{
                    circle.style.fill = SelectedNodes.#default_color
                }
                circle.setAttribute("r", SelectedNodes.#circle_size_default);

            }

            static getNodeData(element){
                let child_nodes = element.childNodes;
                let circle = child_nodes[SelectedNodes.#circle_pos];
                let text = child_nodes[SelectedNodes.#name_pos];
                return [element, circle, text]; // element is g tag
            }

            static addNodes(element) {    
            /* Function to update the set of nodes, going forward each node should probably contain the element by ID and the html element
            
            This class is also being refactored as it should never get a none leaf-node

            param element: a html "g" element to update the colour of
            */        
                let [parent, circle, text] = SelectedNodes.getNodeData(element.closest(SelectedNodes.#svg_parent));
                
                if(!SelectedNodes.nodes.has(text.textContent)){
                    SelectedNodes.nodes.set(text.textContent, parent);
                    SelectedNodes.setSelectedColours(text, circle);
                }
                console.debug(`${text.textContent} already exists in map.`)
                
            }

            static unselectNode(element){
                // Function tied to an on click event removing it from the map, legend and de-colouring it
                let elm = element.closest(SelectedNodes.#svg_parent)
                let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                SelectedNodes.deSelectedColours(text, circle);
                let dropped = SelectedNodes.nodes.delete(text.textContent)

                console.debug("Dropping values:", text.textContent, dropped);
                
            }

            static deselectNodes(){
                for(const n of SelectedNodes.nodes){
                    SelectedNodes.unselectNode(n[SelectedNodes.#circle_pos]);
                }
                SelectedNodes.emptyNodeSelections();
            }

            static emptyNodeSelections(){
                $(SelectedNodes.selection_id).empty();
            }

            static drawSelectedNodes(){
                // Redraw the menu of selected nodes
                // and re-colour selected ones
                $(SelectedNodes.selection_id).empty().append(() => {
                    let attributes = new Array;
                    for(const item of SelectedNodes.nodes.keys()){
                        attributes.push(`<div class="d-flex border-bottom align-items-center selected-node">
                        <div onclick="scroll_into_view_treenode('${item}')" class="flex-grow-1">${item}</div>
                        <div>
                            <button onclick="remove_selected_node(this.dataset.nodeId)" data-node-id="${item}" 
                            class="btn btn-danger m-1 btn-sm">x</button>
                        </div>
                        </div>\n`);
                        
                    }
                    
                    return `${attributes.join("")}`;
                });
            }
        }


        /** Code for parsing a newick tree to be used by D3
         * The code is taken from Knhx.js written by Heng Li
        */
        function kn_new_node() {
            // Heng li code to add node
            //return {parent:null, children:[], name:"", meta:"", d:-1.0, hl:false, hidden:false, leaf:false};
            return {parent:null, children:[], name:"", max_length: 0.0, meta:"", d:0.0, leaf:false};
        }

        function kn_add_node(str, l, tree, x, leaf) // private method
        {
            // Heng Li code to add nodes to a tree
            var r, beg, end = 0, z;
            z = kn_new_node();
            z.leaf = leaf;
            for (i = l, beg = l; i < str.length && str.charAt(i) != ',' && str.charAt(i) != ')'; ++i) {
                var c = str.charAt(i);
                if (c == '[') {
                    var meta_beg = i;
                    if (end == 0) end = i;
                    do ++i; while (i < str.length && str.charAt(i) != ']');
                    if (i == str.length) {
                        tree.error |= 4;
                        break;
                    }
                    z.meta = str.substr(meta_beg, i - meta_beg + 1);
                } else if (c == ':') {
                    if (end == 0) end = i;
                    for (var j = ++i; i < str.length; ++i) {
                        var cc = str.charAt(i);
                        if ((cc < '0' || cc > '9') && cc != 'e' && cc != 'E' && cc != '+' && cc != '-' && cc != '.')
                            break;
                    }
                    // Distance added here
                    z.d = parseFloat(str.substr(j, i - j));
                    --i;
                } else if (c < '!' && c > '~' && end == 0) end = i;
            }
            if (end == 0) end = i;
            if (end > beg) z.name = str.substr(beg, end - beg);
            tree.node.push(z);
            return i;
        }
    
        function kn_parse(str)
            {
                // Heng li Newick parsing code
            var stack = new Array();
            var tree = new Object();
            tree.error = tree.n_tips = 0;
            tree.node = new Array();
            for (var l = 0; l < str.length;) {
                while (l < str.length && (str.charAt(l) < '!' || str.charAt(l) > '~')) ++l;
                    if (l == str.length) break;
                    var c = str.charAt(l);
                    if (c == ',') ++l;
                    else if (c == '(') {
                        stack.push(-1); ++l;
                    } else if (c == ')') {
                        var x, m, i;
                        x = tree.node.length;
                        for (i = stack.length - 1; i >= 0; --i)
                            if (stack[i] < 0) break;
                        if (i < 0) {
                            tree.error |= 1; break;
                        }
                        m = stack.length - 1 - i;
                        l = kn_add_node(str, l + 1, tree, m, false);
                        for (i = stack.length - 1, m = m - 1; m >= 0; --m, --i) {
                            tree.node[x].children[m] = tree.node[stack[i]];
                            tree.node[stack[i]].parent = tree.node[x];
                        }
                        stack.length = i;
                        stack.push(x);
                    } else {
                        ++tree.n_tips;
                        stack.push(tree.node.length);
                        l = kn_add_node(str, l, tree, 0, true);
                    }
            }
            if (stack.length > 1) tree.error |= 2;
            tree.root = tree.node[tree.node.length - 1];
            TREE_ULTRAMETRIC_P = isUltrametric(tree)
            return tree;
        }


        function isUltrametric(tree){
            let stack = new Array();
            let distances = new Set();
            tree.root.max_length = tree.root.d
            stack.push(tree.root)
            while(stack.length > 0){
                let temp = stack.pop()
                if(temp.leaf){
                    // Round the max length, as floating point errors will make numbers
                    // appear sligthly different
                    // The max length is not added again, as the child distance is
                    // added in the else block below
                    distances.add(temp.max_length.toFixed(2))
                }else{
                        temp.children.forEach( (child) => {
                            child.max_length = temp.max_length + child.d
                            stack.push(child)
                        })
                }
            }
            if(distances.size === 1){
                return true
            }
            return false
        }


        //~~~~~~~~~ End of Heng Li's Code


        let CreateMenuItem = (node_type, text, evt_list_func, on_click) => {
            
            let node = document.createElement(node_type);
            
            if(node_type !== "h4"){ // Not liking the way this is formatted
                node.style.cursor = "default";
            }
            node.style.margin = "2px";
            //node.innerHTML = text;
            node.textContent = text;
            if(evt_list_func !== undefined){
                evt_list_func(node);
            }
            if(on_click !== undefined){
                node.onclick = on_click;
            }
            return node;
        }

        let ColourMouseOver = (node) => {
            // Set attributes for colouring of values
            node.classList.add("dropdown-item");
        };

        let AppendToParent = (parent, ...nodes) => {
            nodes.forEach(arg => parent.appendChild(arg));
        };

        let CreateDropDownDiv = (event) => {
            let offset_menu = 0;
            // Temporarily increase node size on collection
            let circle = event.target.parentNode.getElementsByTagName("circle")[0];
            let rad_size = circle.getAttribute("r");
            let increased_size = rad_size * 3;
            if(!RADIUS_INCREASED && MENU_CREATED){
                circle.setAttribute("r", increased_size);
                RADIUS_INCREASED = true;
            }
            
            let drop_down_menu = document.createElement("div");

            drop_down_menu.classList.add("dropdown")

            drop_down_menu.style.position = "fixed";
            drop_down_menu.style.left = event.pageX+'px';
            drop_down_menu.style.top = event.pageY+'px';
            drop_down_menu.style.borderStyle = "solid";
            drop_down_menu.style.borderWidth = "2px";
            drop_down_menu.style.borderRadius = "10pt"
            drop_down_menu.style.backgroundColor = "#FAFCF9";
            drop_down_menu.setAttribute("id", "PopDownMenu");

            // Add event listeners to undo changes when leaving
            drop_down_menu.addEventListener("click", (event) => {
                drop_down_menu.remove();
                circle.setAttribute("r", rad_size);
                RADIUS_INCREASED = false;
                MENU_CREATED = false;
            });

            drop_down_menu.addEventListener("mouseleave", (event) => {
                event.target.remove();
                circle.setAttribute("r", rad_size);
                RADIUS_INCREASED = false;
                MENU_CREATED = false;
            });

            document.getElementById("TreeSVG").addEventListener("mouseover", (event) => {
                drop_down_menu.remove();
                circle.setAttribute("r", rad_size);
                RADIUS_INCREASED = false;
                MENU_CREATED = false;
            })

            return drop_down_menu;
        }

        let NodeDropDownMenu = (event, data, func) => {
            // Rendering dropdown menu on click, it may be better to render a hidden menu for each node in a div
            // This would clutter the dom however
            
            if(event.target.parentNode.classList.contains("inner-node")){
                if(!MENU_CREATED){
                    MENU_CREATED = true;
                    let drop_down_menu = CreateDropDownDiv(event);
                    let title = CreateMenuItem("h4", "Node Options");


                    let collapse_tree = CreateMenuItem("p", "Collapse/Un-collapse branch", ColourMouseOver, func);                    

                    // TODO need to remove selected nodes when drawing subtree
                    let create_subtree = CreateMenuItem("p", "Display Sub-tree", ColourMouseOver, () => {
                        CustomSubTree(event, data);
                    });

                    let select_child_nodes = CreateMenuItem("p", "Select all Children", ColourMouseOver, () => {
                        SelectChildren(event, data);
                    });

                    AppendToParent(drop_down_menu, title, collapse_tree, create_subtree, select_child_nodes);            
                    let tree_element = document.getElementById("TreeData");
                    tree_element.append(drop_down_menu)
                }
            }else{
                LeafNode(event, data);
                SelectedNodes.drawSelectedNodes();
            }
        };

        // Tree specific code for this project implementation
        let CustomSubTree = (event, data) => {
            $("#legend_toggle").bootstrapToggle('off')
            SelectedNodes.drawSelectedNodes();
            $('#colour-legend').empty()
            $('#colour-legend').addClass('d-none')
            $('#TreeSVG').remove()
            $("#scale-bar-menu").remove()
            if(data !== null){
                // Make copy of head node as data will be overwritten
                let copy_head_node = Object.assign({}, data.data);
                let svg_chart = TREE_SWITCH.get(TREE_VAL)(copy_head_node);
                svg_chart.style.paddingLeft = svg_chart.style.paddingLeft + TREE_OFFSET;
                $("#TreeData").append(svg_chart);
                $(".leaf-node").each((i, elm) => {
                    // Maintain colour of already selected nodes

                    let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                    if(SelectedNodes.nodes.has(text.textContent)){
                        SelectedNodes.nodes.set(text.textContent, parent); // update to new parent
                        SelectedNodes.setSelectedColours(text, circle);
                    }
                });
            }
        };

        // Helper function to recurse through child nodes
        let RecurseTree = (data) => {
            let children = new Array;
            let ids = new Array;
            children.push(...data._children);
            while (children.length){
                let child = children.pop();
                if(!child._children){
                    ids.push(child.data.name);
                }else{
                    children.push(...child._children)
                }
            }
            return ids;
        };




        // Select all children of an inner-node
        let SelectChildren = (event, data) => {
            const circle_pos = SelectedNodes.getCirclePos();
            const trg_name_pos = SelectedNodes.getNamePos(); 

            // D3 functions to collect the sub-tree do not appear to be working here
            let selected_children = RecurseTree(data);
            let selected_children_jq = `#TreeSVG [id='${selected_children.join("'], #TreeSVG [id='")}']`;
            $(`${selected_children_jq}`).each((i, d) => {
                SelectedNodes.addNodes(d);
            })
            SelectedNodes.drawSelectedNodes();

        };


        let LeafNode = (event, d) => {
            d.children = d.children ? null : d._children;
            const circle_pos = 1;
            const trg_name_pos = 2;
            let parent = event.target.closest('g').childNodes;
            let trg = parent[circle_pos];
            let node_name = parent[trg_name_pos].textContent;
            if(d.data.leaf){
                if(trg.style.fill === clicked_color){
                    SelectedNodes.unselectNode(event.target);
                }else{
                    SelectedNodes.addNodes(event.target);
                }
            }
        };

        let switchTreeType = (eve) => {
            TREE_VAL = eve.id
            $('#colour-legend').empty()
            $('#colour-legend').addClass('d-none')
            $('#TreeSVG').remove();
            $("#scale-bar-menu").remove()
            let chart_ = null;
            if(tree_root !== null){
                
                chart_ = TREE_SWITCH.get(TREE_VAL)(tree_root);
                chart_.style.paddingLeft = chart_.style.paddingLeft + TREE_OFFSET;
                $("#TreeData").append(chart_);
                $(".leaf-node").each((i, elm) => {
                let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                if(SelectedNodes.nodes.has(text.textContent)){
                        SelectedNodes.nodes.set(text.textContent, parent); // reset dom postion
                        SelectedNodes.setSelectedColours(text, circle);
                    };
                });
                reset_zoom_slider()
                return true;
            }
        };

        

        let drawTree = (newick_) => {
            $("#tree-splash").remove()
            $("#tree-selector").remove()
            $("#tree-upload-button").remove()
            $("#scale-bar-menu").remove()
            let tree = kn_parse(newick_);
            if(tree_root != null){
                console.error("A tree is already drawn");
                return false;
            }
            tree_root = tree.root; // Save the trees root to redraw the tree when needed
            let node_out = TREE_SWITCH.get(TREE_VAL)(tree_root)
            node_out.style.paddingLeft = node_out.style.paddingLeft + TREE_OFFSET;

            $("#TreeData").append(node_out);
            document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            document.querySelector('#TreeData').scrollTo(document.querySelector('#TreeData').scrollWidth/2,0)
        };


        let CreateDataTable = () => {
            data_table = $('#metadata').DataTable({
                //stateSave: true,
                //"paging": false,
                "lengthMenu": [ [10, 25, 50, 100, -1], [10, 25, 50, 100, "All"] ],
                className: ".editable",
                initComplete: function (settings, json) {
                    console.log("DataTables has finished its initialization");
                    
                },
                columnDefs: [{
                        targets: '_all',
                        createdCell : (td, cellData, rowData, row, col) =>
                        {
                            if(col != 0){ // Skip ID column as it should not be editable
                                td.setAttribute('contenteditable', true);
                            }
                        }
                    }
                ],
                //dom: 'lfrtip',
                drawCallback: function(){
        


        //html.innerHTML='<div class="paginate_button displayAll">DISPLAY ALL RECORDS</div>'


        //let icon=document.create("i")
        ///icon.style="position:absolute; top:0; right: 0; cursor: pointer; color:blue; margin-right:1px"
        //icon.id="tree_fullscreen_btn"
        //icon.onclick="tree_full_screen_mode()"

        let html=document.createElement("div");
        html.className = "paginate_button displayAll"
        html.id = "paginate_button_all"
        html.textContent = "ALL records"
        if(document.querySelector("#paginate_button_all") === null){
            document.querySelector("#metadata_paginate").appendChild(html)
        }
        let maximize_button_html=document.createElement("i");
        maximize_button_html.style = "position:absolute; top:0; right: 0; cursor: pointer; color:blue; margin-right:1px"
        maximize_button_html.className="d-flex fs-5 bi-arrow-up-right-square"
        maximize_button_html.id = "metadata_fullscreen_btn"
        maximize_button_html.setAttribute("onclick", "metadata_full_screen_mode()")
        if(document.querySelector("#metadata_fullscreen_btn") === null){
            document.querySelector("#metadata_wrapper").appendChild(maximize_button_html)
        }    
          

        $('.paginate_button.displayAll:not(.disabled)', this.api().table().container())          
        .on('click', function(){
            
            if(data_table.context[0]._iDisplayLength !== -1){
                console.log("Paginate OFF")
                
                //this.textContent="XXXXXX"
                data_table.context[0]._iDisplayLength=-1; //remove pagination
                data_table.draw();
                $('#metadata_length select').val(-1); //change "Show X entires" selector to ALL value
                
                $('#paginate_button_all').text("First 10")
                console.log(this.textContent)
                
            }else{
                console.log("Paginate ON")
                console.log($('#paginate_button_all').text())
                data_table.context[0]._iDisplayLength=10;
                $('#metadata_length select').val(10); //change "Show X entires" selector to ALL value
                //
                data_table.draw();
                $('#paginate_button_all').text("ALL records");
                console.log(this.textContent)
                
            }    
            
        });       
    }

            });
            $('#metadata_filter input').attr("id", "search-bar").attr("class", "table table-striped"); // Give search bar ID to squash warnings

            // TODO initializing table from json object would minimize copies
            // Saving data as a map, to allow for updating of metadata
            ORIGINAL_DATA = new Map();
            data_table.rows().data().each((value, index) => {
                ORIGINAL_DATA.set(value[ID_FIELD], value)
            });

            
            // TODO This can likely be initialized in the above loop pushing to value 
            for(const [key, value] of ORIGINAL_DATA.entries()){
                value.push(false); // Append a key to flag whether the value has been modified    
            }
        };


        let CreateTable = (parsed_data, table_id, table_headers) => {
            $("#table-splash").remove();
            $("#metadata-selector-input").remove();
            $("#metadata-selector").remove();
            let headers = table_headers;
            let table_head = "";
            let table_body = [];
            for(const item of headers){
                table_head = table_head + `<th>${item}</th>\n`;
            }
            for(const item of parsed_data){
                table_body.push('<tr>\n');
                for(const header of headers){
                    table_body.push(`<td class="editable">${item[header]}</td>\n`);
                }
                table_body.push("</tr>\n");
            }

            parsed_data = null; // mark old data for GC
            $(table_id).html("<thead>" + table_head + "</thead>" + "<tbody>" + table_body.join() + "</tbody>");
            // ? A bit odd we are making the table with HTML then converting to jquery datatable...
            CreateDataTable();
        };

        let CreateColoringGroups = (array_vals) => {
            let new_obj = new Object();
            for(const item of array_vals){
                new_obj[item] = new Array;
            }
            return new_obj;
        };

        function rgbToHex(r, g, b) {
            return "#" + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);
        }

        function parseRBGstring(rbgString){
            m = rbgString.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i);
            if( m) {
                return [m[1],m[2],m[3]];
            }
        }

        //fill legend with items
        let CreateNodeLegend = (array_tuples, column_index, value2samples) => {

            let node_leg = $("#colour-legend")
            node_leg.empty()
            node_leg.append(`<div id="drag_legend_button" onmousedown="dragDivByMouse(event)" class="w-100" style="height:5px; background-color:blue; box-shadow: 1px 1px 1px 1px rgba(0,0,0,.8); cursor: all-scroll;"></div>`)

            for(const item of array_tuples){ //[field_value, hex_colour]
                let row_legend_node = $(`<div class="d-flex p-1 border-bottom flex-nowrap align-items-center legend-element"></div>`)
                let field_value=item[0]
                if(field_value === ''){field_value="Not defined"}
                row_legend_node.append(`
                <input type="color" value="${item[1]}" data-sampleID="${value2samples[item[0]].join(',')}"  onchange="changeLegendItemColour(this)" 
                style="width: 20px; height:20px; padding: 1px; border: 1px solid black"></input>\n
                <small onclick="select_deselect_nodes_by_field_value(this, ${column_index})" 
                style="padding-left:5px">${field_value}</small>`)
                node_leg.append(row_legend_node)
            }
            document.querySelector('#colour-legend').classList.remove("d-none");
            document.querySelector('#colour-legend').style.left = `${document.querySelector('#TreeData').scrollLeft}px`

        };
        

        let lineThickness = (ele) => {
            if(ele){
                LINE_THICKNESS = ele.value;
            }
            $("#line-thickness-value").html(`${Number(LINE_THICKNESS).toFixed(1)}`);
            $(".adjustable-line").css('stroke-width', LINE_THICKNESS)
        }


        let changeLegendItemColour = (div) => {
            let prevColourValueHex = div.getAttribute("value");
            let newColourValueHex = `${div.value}`
            div.setAttribute("value",newColourValueHex);
            let legend_update = div.nextElementSibling.innerText;
            div.dataset.sampleid.split(',').forEach( sample_id => {
                let ele = document.querySelector(`#TreeSVG [id="${sample_id}"]`);
                if(ele !== null){
                    let [elem, circle, text] = SelectedNodes.getNodeData(ele);
                    if(SelectedNodes.nodes.has(text.textContent)){
                        // if selected old fill value needs to be updated
                        circle.dataset.oldfill = newColourValueHex;
                    }else{
                        circle.style.fill = newColourValueHex;
                    }
                    
                }
            })

        }

        let PopulateGroups = (json_groups, query_key) => {

            ORIGINAL_DATA.forEach((value, key) => {
                if (value[query_key] in json_groups) {
                    json_groups[value[query_key]].push(key);
                }
                
            });
            return json_groups;
        };

        let ResetTable = () => {
            data_table.clear();
            // ? Is there a more space efficient way to do this?
            data_table.rows.add(Array.from(ORIGINAL_DATA.values())).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);
        };

        let SubsetTable = () => {
            let filtered = data_table.data().filter((value, idx) => {
                return SelectedNodes.nodes.has(value[ID_FIELD]);
            });
            data_table.clear();
            data_table.rows.add(filtered).draw();
            $("td").addClass("editable");
            $("td:not(:first-child)").attr("contenteditable", true);

        };



        let initialize_legend_menu = () => {
            // update the legend text to reflect loading
            let button = document.querySelector("#legend_dropdown_button");
            button.textContent = "Colour tree by column";
            button.dataset.bsToggle = "dropdown";
            button.classList.remove("btn-danger");
            button.classList.add("btn-primary");
        }

        let initialize_tree_menu = () => {
            let button = document.querySelector("#tree_dropdown_menu")
            button.textContent = "Select a tree layout"
            button.dataset.bsToggle = "dropdown";
            let tree_types = new Array;
            tree_types.push('<div class=\"dropdown-menu\" id=\"tree-layouts\" style=\"overflow:visible;\">')
            TREE_SWITCH.keys().forEach( (ele) => {
                tree_types.push(`\t<a onclick="switchTreeType(this)" class="dropdown-item" href="#" id="${ele}">${ele}</a>`)
            })
            $("#dropdown_tree_types").append(tree_types.join("\n"))

        }

        let create_legend_elements = (headers) => {
                // Create html elements for the dropdown menu of itmes to creat the legend by
                let text = new Array;
                text.push('<div class=\"dropdown-menu\" id=\"legend-items\" style=\"overflow:visible;\">')
                let header_offset = headers.slice(1);
                header_offset.forEach((ele, idx) => {
                    text.push(`\t<a onclick="colour_by_element(this)" class="dropdown-item" href="#" id="${idx+1}">${ele}</a>`)
                });
                text.push("</div>\n")
                return text.join("\n")
        }
        
        let colour_by_element = (ele) => {
            // Create a legend for the column selected
            if(tree_root === null){
                // TODO add pop up
                console.error("No newick loaded")
                return null
            }

            let col_index = ele.id;
            $("#legend_toggle").bootstrapToggle('on')

            let unq_data = new Set();
            ORIGINAL_DATA.forEach((value, key) => {
                unq_data.add(value[col_index])
            })

            // Need to create groupings of the each set of ID's belonging to each value grouping
            let break_down_values = Array.from(unq_data);
            break_down_values.sort()
            
            // Instead of searching the array for ID's using the datatable, I am just going to use a linear look up
            let group_vals = CreateColoringGroups(break_down_values); // {"unique_item":[],"unique_item2":[]}
            break_down_values = PopulateGroups(group_vals, col_index); //{"unique_item":["id1","id2"...],"unique_item2":["id3"]}
            

            let colours = randomColor({luminosity: 'dark', count: Object.keys(break_down_values).length, seed: 42, format: "hex"});
        
            /* Heuristic alogrithm to pick non-overlapping colours above threshold */ 
            
            //given a random colours for legend items find highly similar colours below the deltaE2000 threshold
            if(colours.length <= 50){
                const deltaE2000_threshold = 10;
                let problematic_colours_idx=[];
                colours.map((picked_color, j)=>{
                
                    //find highly similar colours in a panel below deltaE2000_threshold
                    for (const [i,legend_color] of colours.entries()){
                        let deltaE2000 = Color.deltaE2000(picked_color, legend_color)
                        if(deltaE2000 <= deltaE2000_threshold && deltaE2000 !== 0){
                            problematic_colours_idx.push(i)            
                        }

                    }//for loop ends

                    problematic_colours_idx = [ ... new Set(problematic_colours_idx)].sort((a,b)=> a-b)
                
                });

                console.debug(`Found problematic too similar ${problematic_colours_idx} with indices ${problematic_colours_idx.length} out of ${colours.length}`)    
                
                //if highly similar colours in legend found, try to find a suitable replacement that will be above the deltaE2000_threshold
                //try randomly pick 1000 colours and test them against all colours in the legend
                let found_new_color_bool = false;
                problematic_colours_idx.forEach(i =>{
                    found_new_color_bool = false

                    const seed_offset = parseInt(Math.random()*100000)+1;
                    const max_random_colours = 1000;
                    colour_random_list = randomColor({ seed: seed_offset, count: max_random_colours, format:'hex'})
                
                    for(const random_color_hex of colour_random_list) {
                        //check distance to all colours in the legend
                        let deltaE2000_list = colours.map(legend_color => {
                            return Color.deltaE2000(random_color_hex, legend_color)
                        });
                        let minDeltaE2000 = Math.min(...deltaE2000_list)
                    
                        if(minDeltaE2000 > deltaE2000_threshold){
                            console.debug(`Found a suitable color ${random_color_hex} with min deltaE2000 ${minDeltaE2000} for ${Object.keys(break_down_values)[i]}`)
                            colours[i] = random_color_hex;
                            found_new_color_bool = true;
                            break;
                        }
                    }//for      
                    
                });//forEach ends 
            }//if ends


            let colour_idx = 0;
            colour_legend.length = 0; // clear out old data, so new legend created each time
            for(const item in break_down_values){
                break_down_values[item].forEach((x, i) => {
                    try{
                        let current_item = document.querySelector(`[id='${x}']`);
                        let [elem, circle, text] = SelectedNodes.getNodeData(current_item);
                        if(SelectedNodes.nodes.has(x)){
                            circle.dataset.oldfill = colours[colour_idx];
                        }else{
                            circle.style.fill = colours[colour_idx];
                        }
                        
                    }catch(error){
                        console.error("Could not find ", x, " In DOM");
                        console.error(error); 
                    }
                });
                colour_legend.push([item, colours[colour_idx]])
                colour_idx++;
            }
            CreateNodeLegend(colour_legend, col_index, break_down_values);    

        };

        let redrawTree = () => {

                $('#colour-legend').empty()
                $('#colour-legend').addClass('d-none')
                $('#TreeSVG').remove();
                $("#scale-bar-menu").remove()
                let chart_ = null;
                if(tree_root !== null){
                    chart_ = TREE_SWITCH.get(TREE_VAL)(tree_root);
                    chart_.style.paddingLeft = chart_.style.paddingLeft + TREE_OFFSET;
                    $("#TreeData").append(chart_);
                    $(".leaf-node").each((i, elm) => {
                        let [parent, circle, text] = SelectedNodes.getNodeData(elm);
                        if(SelectedNodes.nodes.has(text.textContent)){
                            SelectedNodes.nodes.set(text.textContent, parent); // reset dom postion
                            SelectedNodes.setSelectedColours(text, circle);
                    };
                });
                    reset_zoom_slider()
                    return true;
                }
                console.error("No tree to redraw");
        }

        $(() => {


            $("#redraw-tree-button").on("click", () => { redrawTree() });

            initialize_tree_menu();
            lineThickness();


            // ! Below disables the right click menu for the page
            document.oncontextmenu = (event) => {
                // Disables context menu for TreeData div, e.g. default web menu does not appear
                let item_id = event.target.closest("div").id;
                return true;
            };

            // Check if TREE is defined or injected via the inline_arborview.py script (used by Arborator and GAS)
            if(TREE != __DEADBEEF__){
                // If a valid TREE variable is defined
                if(TREE != __DEADBEEF__){
                    // Render the actual TREE data
                    drawTree(TREE);
                }
            }

            $("#tree-selector").change((event) => {
                let reader = new FileReader();
                let newick_file = event.target.files[0];
                reader.readAsText(newick_file, "UTF-8");
                console.log(`Successfully loaded ${newick_file.name}`)
                reader.onload = (evt) => {
                    newick = evt.target.result;
                    drawTree(newick);
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${newick_file}`);
                };
            });


            $("#ResetTree").on("click", (evt) => {
                
                if(focused_element !== null){
                    // Revert any focused node back to its original colours
                    // TODO perhaps this should be dropped as there is a redraw tree option
                    focused_element.setAttribute('fill', "black");
                }
                let svg = document.querySelector('#TreeSVG')
                let og_box = svg.getBBox();
                svg.style.width = `${og_box.width}`
                //scroll to middle of the div
                document.querySelector('#TreeData').scrollLeft = document.querySelector('#TreeData').clientWidth/2
                reset_zoom_slider()
            });


            $("#metadata").on("blur", ".editable", (evt)=>{
                // Update element        
                let row_values = evt.target.closest("tr").childNodes;        
                let edited_value = row_values[0].textContent;
                let retrieved_value = ORIGINAL_DATA.get(edited_value);
                let retrieved_val_length = retrieved_value.length;
                let updated_bool_pos = retrieved_val_length -1; // last value in list is a boolean for wether the data has been modified

                let updated = false;
                for(let i = 0; i < updated_bool_pos; i++){ 
                    if(row_values[i].textContent !== retrieved_value[i]){
                        // can alternatively use str1.localeCompare(str2)
                        retrieved_value[i] = row_values[i].textContent;
                        updated = true
                    }
                    
                }

                // only update the row if the values are new
                if(updated){
                    retrieved_value[updated_bool_pos] = true;
                }
            });

            if(DATA != __DEADFOOD__){
                /*
                Optimization Note:

                Initially just pasting in the string for the metadata which may or may not be a good thing...
                
                It could be slow due to the over head of the object existing as text in the page and in memory
                TODO remove selectors
                */

                // Create METADATA to load in
                let processing = true;
                const blankQuitter = (d, i) => {
                        const blankRow = Object.keys(d).every(k => !d[k]);
                        if (blankRow) processing = false;
                        if (processing) return d;
                }
                METADATA = d3.tsvParse(DATA, blankQuitter);
                TABLE_HEADERS = METADATA.columns;
                CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                METADATA = null;
                initialize_legend_menu();
                $("#dropdown_legend").append(create_legend_elements(TABLE_HEADERS));
            }

            $("#metadata-selector").change((event) => {
                let reader = new FileReader();
                let metadata_file = event.target.files[0];

                reader.readAsText(metadata_file, "UTF-8");
                reader.onload = (evt) => {
                    // TODO scrub empty rows on reading, e.g. force a sample id to be filled
                    let metadata = evt.target.result;
                    // Blank quitter function from: https://stackoverflow.com/questions/67793952/is-there-an-easy-way-to-stop-d3-csvparse-when-it-hits-a-blank-line
                    let processing = true;
                    const blankQuitter = (d, i) => {
                        const blankRow = Object.keys(d).every(k => !d[k]);
                        if (blankRow) processing = false;
                        if (processing) return d;
                    }
                    METADATA = d3.tsvParse(metadata, blankQuitter);
                    TABLE_HEADERS = METADATA.columns;
                    CreateTable(METADATA, "#metadata", TABLE_HEADERS);
                    METADATA = null;
                    initialize_legend_menu();
                    $("#dropdown_legend").append(create_legend_elements(TABLE_HEADERS));
                };
                reader.onerror = (evt) => {
                    alert(`Could not read file ${metadata_file}`);
                };
                
            });

            $("#metadata-search-button").on('click', SubsetTable);
            $("#reset-table-button").on('click', ResetTable);


            $("#metadata").on( "dblclick", "tr:not(:first) td:first-child", function(evt) {
                console.debug(`trying to add ${evt.target.textContent}`)
                
                let tree_node = document.querySelector( `[id='${evt.target.textContent}']`)
                let text = tree_node.lastChild
                let circle = tree_node.querySelector('circle')
                if(SelectedNodes.nodes.has(text.textContent)){
                    SelectedNodes.unselectNode(text);
                }else{
                    SelectedNodes.addNodes(text);
                }

                SelectedNodes.drawSelectedNodes();
                
            } );



            // TODO need to change from sorting_1, to  :first
            // Zoom in on a NODE on single click event
            $("#metadata").on('click', 'tr td:first-child', (evt) => {
                console.debug(`ZOOMING on node selected in metadata table ${evt.target.textContent}`)
                
                let identified_point = document.querySelector(`[id='${evt.target.textContent}']`)
                let identified_point_id = identified_point.childNodes[0].textContent; // gets nodes name
                let is_selected = SelectedNodes.nodes.has(identified_point_id);
                let is_selected_focus = false;
                if(focused_element !== null){
                    is_selected_focus = SelectedNodes.nodes.has(focused_element.childNodes[0].textContent);
                }
                
                // if there is a foucsed item, the new focused item is not selected and the focused item is not selected
                // set its texts to black
                if(focused_element !== null && !is_selected_focus){
                    // Return elements state unless it is already adjusted due to being selected 
                    focused_element.childNodes[2].style.fill = "black";
                }
                focused_element = identified_point; // Save reference to new point

                if(!is_selected){
                    // Highlight selected item unless it is already highlighted due to being selected
                    console.debug("Selected element", identified_point)
                    identified_point.childNodes[2].style.fill = clicked_color;
                }
                
                let rect = identified_point.getBBox();
                let translated_coords = identified_point.getAttribute('transform').replace('translate(', '').replace(")", '').split(",");
                let rect_x = parseFloat(translated_coords[0]);
                let rect_y = parseFloat(translated_coords[1]);
                let svg = document.querySelector('#TreeSVG')
                
                //delay execution so that double click event is possible on the metadata row
                setTimeout(function() {
                    scroll_into_view_treenode(`${evt.target.textContent}`)
                },500);    
                
            });

            $("#TreeData").on('scroll', '#TreeSVG', (evt) => {
                console.debug("scrolling");
            });

        });

        zoom_tree = function(){

            const zoom_times = parseFloat(document.querySelector('#zoom_slider').value)
            const tree_data_elm = document.querySelector('#TreeData')
            const tree_svg = document.querySelector('#TreeSVG')
            document.querySelector('#zoom_slider_value').textContent =  zoom_times 
        
            const new_width = ORIGINAL_WIDTH_SVG  * zoom_times //use global value as getBBox() at high zooms gives wrong values
            const prev_width = parseFloat(document.querySelector('#TreeSVG').style.width)

            //Previous x and y scroll positions before applying a zoom
            const prev_x_scroll_pos = tree_data_elm.scrollLeft
            const prev_y_scroll_pos = tree_data_elm.scrollTop
            document.querySelector('#TreeSVG').style.width = new_width ; //modify width of SVG tree

            //store new translated x and y coordinates after zooming 
            let zoom_x_translated = 0 
            let zoom_y_translated = 0
            const scaleChange = new_width/prev_width //sometimes the specified zoom factor is not exact, use this value instead
            
            //keeping zoom centered on an element
            if(new_width > prev_width){
                //get previous scroll position which is the left most x-coordinate position of a view
                //translate that coordiante to a new zoomed state
                //add 1/4 view field length scaled to a new zoomed state coordinate
                zoom_x_translated =  prev_x_scroll_pos*scaleChange + (tree_data_elm.clientWidth/4)*(scaleChange)
                zoom_y_translated =  prev_y_scroll_pos*scaleChange + (tree_data_elm.clientHeight/4)*(scaleChange)
            
            }else{
                //Zooming out 
                //Scale current scroll position (previous scroll + 1/4 view field distance) to a new coordinate zoomed out state
                //Substract the 1/4 offeset/margin that is already in the needed zoomed out state (no adjustments)
                zoom_x_translated =  prev_x_scroll_pos*scaleChange - (tree_data_elm.clientWidth/4)
                zoom_y_translated =  prev_y_scroll_pos*scaleChange - (tree_data_elm.clientHeight/4)
            
            }
            document.querySelector('#TreeData').scrollTo(zoom_x_translated,zoom_y_translated)
        }

        scroll_into_view_treenode = function(id){
            let selectedNode = document.querySelector(`[id='${id}']`)
            if(selectedNode !== null){
                selectedNode.scrollIntoView({block: "center", inline:"center", behavior: "smooth"})
            }else{
                console.error(`scroll_into_view_treenode(): Node ${id} is not available in this tree. Uncollapse all nodes`)
            } 
        }

        scale_bar_on_off = function(node){
            $(".scale-bar").css("visibility", () => {
                if(!node.checked){
                    return "hidden"
                }else{
                    return "visible"
                }
            })
        }

        legend_on_off = function(node){
            console.debug(node.checked)
            
            if(node.checked === false){
                document.querySelector('#colour-legend').classList.add("d-none");
            }else{
                document.querySelector('#colour-legend').classList.remove("d-none");
            }
        }

        round_decimals = function(){
            let rounding = $("#decimal-slider").val();
            $("#decimal-slider-value").text(rounding);
            DECIMAL_PLACES = rounding;
            redrawTree(); // Need to redraw the tree to update the svg text
        }


        branch_lengths_on_off = function(node){
            SHOW_BRANCH_LENGTHS = !SHOW_BRANCH_LENGTHS;
            $(".branch-length").css("visibility", () => {
                            if(!SHOW_BRANCH_LENGTHS){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        });
        }
        
        let show_inner_node_labels = (node) => {
            SHOW_METADATA_IN_NAME = !SHOW_METADATA_IN_NAME
            $(".inner-node-label").css("visibility", () => {
                            if(!SHOW_METADATA_IN_NAME){
                                return "hidden"
                            }else{
                                return "visible"
                            }
                        });
        }


        scroll_legend_into_view = function(node,full_screen_btn, node_TreeData){
            if(node !== null){
                node.style.left=`${node_TreeData.scrollLeft}px`
                node.style.top=`${node_TreeData.scrollTop}px`
                full_screen_btn.style.right = `-${node_TreeData.scrollLeft}px`
                full_screen_btn.style.top = `${node_TreeData.scrollTop}px`

            }else{
                console.error('No legend rendered skipping scroll_legend_into_view()')
            }    
        }

        reset_zoom_slider = function(){
            document.querySelector('#zoom_slider_value').textContent = 1
            document.querySelector('#zoom_slider').value = 1
        }    

        let select_deselect_nodes_by_field_value = (legend_node, column_index) => {

            //find indices of filtered data in a metadata table
            let indexes = data_table.rows( (idx, data, node) => {
                if(data[column_index] === `${legend_node.textContent}` ){
                    return true
                }else{
                    return false
                }
            } ).indexes()
            
            let selected = legend_node.classList.contains('fw-bold') ? true : false
            
            if(!selected){
                legend_node.classList.add('fw-bold');
            }else{
                legend_node.classList.remove('fw-bold');
            }

            let selected_node_ids = data_table.cells(indexes,0).data();
            for(var i = 0; i < selected_node_ids.length; i++) {
                let tree_node = document.querySelector( `[id='${selected_node_ids[i]}']`)
                let [ele, circle, text] = SelectedNodes.getNodeData(tree_node);

                if(!selected){
                    if(circle.dataset.oldfill){
                        circle.dataset.oldfill = circle.style.fill;
                    }
                    SelectedNodes.addNodes(text);
                }else{
                    SelectedNodes.unselectNode(text);
                }    
            }
            // Bring the terminal node into frame
            terminal_node = document.querySelector(`[id=${selected_node_ids[selected_node_ids.length-1]}`);
            terminal_node.scrollIntoView({block: "center", inline: "center"})
            SelectedNodes.drawSelectedNodes();
            
        }

        remove_selected_node = function(node_id){
            let trg_node = SelectedNodes.nodes.get(node_id);
            SelectedNodes.unselectNode(trg_node);
            SelectedNodes.drawSelectedNodes();
        }

        let original_data_blob = (headers) => {
            // Create a text string of the original data
            let output_text = new Array();
            output_text.push(headers.join("\t"))
            
            for(const [key, value] of ORIGINAL_DATA.entries()){
                output_text.push(value.join("\t"))
            }
            return output_text;
        };

        let filtered_data_blob = (headers) => {
            let output_text = new Array();
            output_text.push(headers.join("\t"))
            data_table.rows().data().each((value, index) => {
                output_text.push(value.join("\t"))
            });
            return output_text;
        }

        export_metadata_table = function(e){
            // Export updated metadata
            console.debug(e.id)
            if(!ORIGINAL_DATA){
                console.error("No contextual data imported yet");
                Swal.fire({
                    title: "Error",
                    text: "No metadata table imported yet. Please upload data first!",
                    icon: "error"
                    });
                return false;
            }
            let headers = Array.from(TABLE_HEADERS);
            headers.push("modified"); // Values track what have been modified however it is not in the original headers
            let output_text = null;
            let updated_metadata = null;
            if(e.id === "export-metadata-table"){
                output_text = original_data_blob(headers);
                updated_metadata = "FullClusterInfo.tsv";
            }else if(e.id === "export-metadata-view"){
                output_text = filtered_data_blob(headers);
                updated_metadata = "FilteredClusterInfo.tsv"
            }else{
                console.error("Unknown element specified for export of data.")
                return false;
            }

            const blob = new Blob([output_text.join("\n")], {type: "text/tsv"} );


            if(window.navigator.msSaveOrOpenBlob){
                // thank stackoverflow for this: https://stackoverflow.com/questions/3665115/how-to-create-a-file-in-memory-for-user-to-download-but-not-through-server
                window.navigator.msSaveBlob(blob, updated_metadata);
            }else{
                const elem = window.document.createElement('a');
                elem.href = window.URL.createObjectURL(blob);
                elem.download = updated_metadata;
                document.body.appendChild(elem);
                elem.click();
                document.body.removeChild(elem);
                window.URL.revokeObjectURL(elem.href); // revoke object url as it wont be cleared till after the browser is closed otherwise
            }
            Swal.fire({
                    title: "Exported Metadata",
                    text: `Exported ${output_text.length-1} rows of metadata saved in ${updated_metadata}`,
                    icon: "info"
                    })
            return true;

        }

        //adapted from https://observablehq.com/@mbostock/saving-svg by Mike Bostock
        serialize2svg = function(svg) {
            const xmlns = "http://www.w3.org/2000/xmlns/";
            const xlinkns = "http://www.w3.org/1999/xlink";
            const svgns = "http://www.w3.org/2000/svg";
            svg = svg.cloneNode(true);
                        
            const lgd = document.getElementById("colour-legend");
            const legend_width = lgd.clientWidth;

            const fragment = window.location.href + "#";
            const walker = document.createTreeWalker(svg, NodeFilter.SHOW_ELEMENT);
            while (walker.nextNode()) {
            for (const attr of walker.currentNode.attributes) {
                if (attr.value.includes(fragment)) {
                    attr.value = attr.value.replace(fragment, "#");
                    }
                }
            }

            svg.setAttributeNS(xmlns, "xmlns", svgns);
            svg.setAttributeNS(xmlns, "xmlns:xlink", xlinkns);

            // Clone style elements to add incorporate into the SVG file
            const css_export = document.createElement("defs")
            const link_style_sheet = document.createElement("link");
            link_style_sheet.setAttribute("href", "https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css");
            link_style_sheet.setAttribute("rel", "stylesheet");
            link_style_sheet.setAttribute("crossorigin", "anonymous");
            css_export.appendChild(link_style_sheet);
            svg.insertBefore(css_export, svg.firstChild);

            const tree_svg = svg.querySelector("#TreeSVG");
            const offset_safety_factor = 20;
            tree_svg.style.marginLeft = legend_width + offset_safety_factor;

            const serializer = new window.XMLSerializer;
            const xml_string = serializer.serializeToString(svg);
            return [new Blob([xml_string], {type: "image/svg+xml"}), xml_string];
        }


        export_tree_to_svg = function(){
            const date = new Date();
            let downloadLink = document.createElement("a");
            downloadLink.download = 'tree_snapshot_'+date.getDate()+'-'+
                (date.getMonth()+1)+'-'+date.getFullYear()+'_'+date.getHours()+'h.svg';
            let svg =  document.getElementById("TreeData").cloneNode(true)
            //remove duplicated leaf nodes text duplication for more accurate searches
            svg.querySelectorAll('g .tree-node').forEach(node => {
                text_nodes_leafs = node.querySelectorAll('text[class=""]')
                if(text_nodes_leafs.length === 2){
                    text_nodes_leafs[0].remove()
                }
            })  
            const blob = serialize2svg(svg)[0];
            downloadLink.href = window.URL.createObjectURL(blob);
            downloadLink.click(); //Trigger a click on the element
            downloadLink.remove();               
        }

        /*Adapted from https://gist.github.com/tatsuyasusukida/1261585e3422da5645a1cbb9cf8813d6 and https://zooper.pages.dev/articles/how-to-convert-a-svg-to-png-using-canvas*/
        export_tree_to_png = function(){
            let svg =  document.getElementById("TreeSVG")
            let svg_width = svg.getBoundingClientRect().width;
            let svg_height = svg.getBoundingClientRect().height;
            //extract SVG element
            const svgData = new XMLSerializer().serializeToString(svg);

            //create canvas to the size of the SVG
            let canvas = document.createElement('canvas')
            canvas.width = svg_width+svg_width*0.05;
            canvas.height = svg_height+svg_width*0.15;
            
            //create SVG image element
            let img = new Image();
            img.src = "data:image/svg+xml;base64," + btoa(svgData);

            img.onload = function () { //must be inside this image onload event function due to async image load nature
                //render SVG image onto canvas element
                let ctx = canvas.getContext('2d');
                ctx.fillStyle = "white";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                //create PNG image from the canvas
                let pngUrl = canvas.toDataURL('image/png').replace('image/png', 'octet/stream');
                //create download link
                let downloadLink = document.createElement("a");
                downloadLink.download = 'tree_snapshot.png';
                downloadLink.href = pngUrl;
                downloadLink.click();
                downloadLink.remove();
            }


            


        }    

        tree_full_screen_mode = function(){
            if (document.fullscreenElement === null){
                document.querySelector('#TreeData').requestFullscreen()
            }else{
                document.exitFullscreen();  
            }    
            
        }

        metadata_full_screen_mode = function(){
            let metadata_panel = document.querySelector('#ClusterInfo>div')
            if (document.fullscreenElement === null){
                METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH = metadata_panel.style.height;
                document.querySelector('#ClusterInfo').requestFullscreen()
                metadata_panel.style.height = '100vh';
            }else{
                document.exitFullscreen();
                console.log(METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH);
                metadata_panel.style.height = METDATA_TABLE_NON_FULL_SCREEEN_HEIGTH;
            }            
        }

        document.addEventListener("DOMContentLoaded",()=>{
            let button = document.querySelector('#tree_fullscreen_btn')

            /*document.querySelector('#TreeData').addEventListener("fullscreenchange", (event) => {
                
                if(button.classList.contains("d-none")){
                    button.classList.remove('d-none')
                }else{
                    button.classList.add('d-none')
                }
            })*/

            document.querySelector('#ClusterInfo').addEventListener('hidden.bs.collapse', function () {
                let heightMetaDiv = document.querySelector('#ClusterInfo>div').style.height
                let heightTreeDataDiv = document.querySelector('#TreeData').style.height
                let unit = heightTreeDataDiv.match(/.?(\w{1,2})$/)[1]
                document.querySelector('#TreeData').style.height= parseFloat(heightTreeDataDiv) + parseFloat(heightMetaDiv)+unit
                document.querySelector('#control_panel').style.height = parseFloat(heightTreeDataDiv) + parseFloat(heightMetaDiv)+unit
                document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            })
            document.querySelector('#ClusterInfo').addEventListener('show.bs.collapse', function () {
                let heightMetaDiv = document.querySelector('#ClusterInfo>div').style.height
                let heightTreeDataDiv = document.querySelector('#TreeData').style.height
                let unit = heightTreeDataDiv.match(/.?(\w{1,2})$/)[1]
                document.querySelector('#TreeData').style.height= parseFloat(heightTreeDataDiv) - parseFloat(heightMetaDiv)+unit
                document.querySelector('#control_panel').style.height = parseFloat(heightTreeDataDiv) - parseFloat(heightMetaDiv)+unit
                document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            })

    
        });    


        clear_selected_nodes = function(){
            // Clear selected nodes and un-bold legend text
            SelectedNodes.deselectNodes(); // deselect nodes
            SelectedNodes.clearNodes();
            // a way to de colour all of these nodes probably exists
            $(".legend-element > .fw-bold").each((it, ele) => {
                ele.classList.remove("fw-bold");
            })

        }

        copy_ids_to_clipboard = function(){
            let text2copyArray=[]
            
            document.querySelectorAll('#SelectedNodes div>div:first-child').forEach(node => {
                console.debug(node.textContent)
                text2copyArray.push(node.textContent)
            })

            if(text2copyArray.length > 0){
                let text2copy = text2copyArray.join('\n');
                navigator.permissions.query({ name: "clipboard-write" }).then((result) => {
                    if (result.state === "granted" || result.state === "prompt") {
                        navigator.clipboard.writeText(text2copy)
                        Swal.fire({
                            html: `<p>Successfully copied ${text2copyArray.length} node IDs to the clipboard<br>Generate a text file with the ${text2copyArray.length} IDs?</p>`,
                            icon: "info",
                            showDenyButton: true,
                            showCancelButton: false,
                            confirmButtonText: 'Yes',
                            denyButtonText: 'No'
                        }).then( (result) => {
                            if (result.isConfirmed) {
                                let success_msg = `Copied ${text2copyArray.length} sample IDs to the clipboard`
                                if(DEBUG){
                                    console.log(text2copy);
                                }
                                let file = new File(["\ufeff"+text2copy], 'selectedNodes.txt', {type: "text/plain:charset=UTF-8"})
                                //create a ObjectURL in order to download the created file
                                url = window.URL.createObjectURL(file);
                                let a = document.createElement("a");
                                a.style = "display: none";
                                a.href = url;
                                a.download = file.name;
                                a.click();
                                window.URL.revokeObjectURL(url);
                            }
                        });
                    }    

                });

                
            }
            else{
                Swal.fire({
                    html: "<b>No nodes to copy and export!</b><p>Select tree node(s) first and try again</p>",
                    icon: "error"
                    });
                
            }            

        }

        vertical_div_resize = function(event){
            event.preventDefault()
            let cursor_pos_init = event.y
            metadata_panel = document.querySelector('#ClusterInfo>div')
            treeData_panel = document.querySelector('#TreeData')
            control_panel = document.querySelector('#control_panel')
            let metadata_panel_height_init = metadata_panel.getBoundingClientRect().height
            let treeData_panel_height_init = treeData_panel.getBoundingClientRect().height
            let control_panel_height_init = control_panel.getBoundingClientRect().height
            document.addEventListener('mousemove', resize, false)
            document.addEventListener('mouseup', stop_resize, false)
            function resize(event){
                event.stopPropagation();
                const dy = event.y - cursor_pos_init  
                metadata_panel.style.height = metadata_panel_height_init - dy+'px'
                treeData_panel.style.height  = treeData_panel_height_init + dy+'px'
                control_panel.style.height = control_panel_height_init + dy+'px'
            }
            function stop_resize(event){
                document.removeEventListener('mousemove', resize)
                document.querySelector('#SelectedNodes').style.maxHeight = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
            }    
        }
        document.addEventListener('mouseup',(event)=>{
                document.removeEventListener('mousemove', vertical_div_resize,false)
        })
    window.onload = function(){
        let heightSelectedNodesPanel = `${document.querySelector('#TreeData').offsetHeight - document.querySelector('#tree_menu_buttons').offsetHeight}px`
        document.querySelector('#SelectedNodes').style.cssText = `height: ${heightSelectedNodesPanel}; max-height: ${heightSelectedNodesPanel} `

    }    

    //The Bootstrap dropdown-menu position absolute css is not working and menu is obscured by other divs
    //This fixes the issue as we do not want to modify original BS code
    dropdownmenufix = function(){
        document.querySelector('.dropdown-menu').style['position']="fixed"
    }

    dragDivByMouse = function(event) {
        let isDown = true;
        let legend_div = document.querySelector('#colour-legend')
        let control_panel_div = document.querySelector("#control_panel")
        let TreeData_div = document.querySelector('#TreeData')
        let offset = {"x": event.clientX - control_panel_div.offsetWidth, "y": event.clientY + TreeData_div.scrollTop}   
        document.addEventListener('mouseup', function(){isDown = false}, true)
        document.addEventListener('mousemove', move, true)
        function move(event){
            event.preventDefault();
            if(isDown === true){
                offset = {"x": event.clientX-control_panel_div.offsetWidth, "y": event.clientY + TreeData_div.scrollTop}
                legend_div.style['left'] = offset.x+"px"
                legend_div.style['top'] = offset.y+"px"
            }    
        }
    }

    </script>
</head>
    <body>
        <div class="container-fluid m-0">
            <div class="row"> <!-- id="TreeSelections" style=""-->
                <div id="control_panel" class="col-2 border border-primary px-1 overflow-auto">
                    <div id="tree_menu_buttons" class="row m-0">
                                <div class="d-flex flex-row align-items-center p-0 text-left mt-1">
                                    <button class="h-100 flex-grow-1 me-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Select a newick file" onclick="document.getElementById('tree-selector').click();" name="newick" id="tree-upload-button">
                                        <i class="bi bi-upload me-1"></i>Newick <i class="bi bi-tree ml-1"></i>
                                    </button>
                                    <input  type="file" id="tree-selector" name="tree-selector" accept=".nwk, .newick, .treefile" hidden> 
                                    <button class="h-100 flex-grow-1 btn-sm btn-primary text-break" data-toggle="tooltip" data-placement="top" 
                                        title="Select a tab delimited metadata file" onclick="document.getElementById('metadata-selector').click();" 
                                        id="metadata-selector-input" name="metadata-selector-input">
                                        <i class="bi bi-upload me-1"></i>Meta <i class="bi bi-file-spreadsheet ml-1"></i>
                                    </button>
                                    <input type="file"  id="metadata-selector" 
                                    name="metadata-selector" accept=".tsv, .tab" hidden>
                                </div>
                                <button type="button" class="btn-sm btn-primary w-100 text-break mb-1 mt-1" data-toggle="tooltip" data-placement="top" 
                                    title="Clear filters applied to the metadata table." name="ResetTable" id="reset-table-button">Clear filters</button>                                
                                
                                <div class="d-flex flex-row align-items-center p-0 text-left">
                                    <button class="flex-grow-1 btn-sm btn-primary text-break me-1 mb-1" data-toggle="tooltip" data-placement="top"  
                                        title="Copy selected node IDs to your clipboard to paste into another application and optionally generate a text file" onclick="copy_ids_to_clipboard()" name="CopyIDs" id="copy-ids-button">
                                        <i class="bi bi-clipboard me-1"></i>IDs
                                    </button>
                                    <button class="flex-grow-1 btn-sm btn-primary text-break me-1 mb-1" data-toggle="tooltip" data-placement="top" 
                                        title="Export the tree to SVG." onclick="export_tree_to_svg()" id="export-tree-to-svg">
                                        <i class="bi bi-download m-1"></i> SVG
                                    </button>
                                    <button class="flex-grow-1 btn-sm btn-primary text-break mb-1" data-toggle="tooltip" data-placement="top" 
                                        title="Export the tree to PNG." onclick="export_tree_to_png()" id="export-tree-to-png">
                                        <i class="bi bi-download m-1"></i> PNG
                                    </button>
                                </div>
                                <div class="dropdown p-0">
                                    <button class="w-100 flex-grow-1 mb-1 btn-sm btn-primary dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        <i class="bi bi-download me-1"></i> Export Meta Table
                                    </button>
                                    <ul class="dropdown-menu">
                                        <li><a id="export-metadata-view" data-toggle="tooltip" data-placement="top" title="Export the currently selected metadata." 
                                        class="dropdown-item flex-grow-1 me-1 btn-sm btn-primary text-break mb-1" onclick="export_metadata_table(this)" id="export-metadata-view">
                                            <i class="bi bi-download me-1"></i> Export Filtered Table
                                            </a>
                                        </li>
                                        <li><a id="export-metadata-table" data-toggle="tooltip" data-placement="top" title="Export the currently selected metadata." 
                                            class="dropdown-item flex-grow-1 me-1 btn-sm btn-primary text-break mb-1" onclick="export_metadata_table(this)" id="export-metadata-view">
                                                <i class="bi bi-download me-1"></i> Export Full Table
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <!--Tree layout slider-->
                                <div class="d-flex flex-row align-items-center p-0 text-left">
                                    <button data-toggle="tooltip" data-placement="top" title="Redraw the entire tree undoing any changes." 
                                    class="btn-sm btn-primary w-100 h-100 text-break me-1" name="RedrawTree" id="redraw-tree-button"><i class="bi bi-pencil-square"></i> Redraw Tree</button>
                                    <button data-toggle="tooltip" data-placement="top" title="Bring the tree back into focus" class="btn-sm btn-primary w-100 h-100" name="ResetTree" id="ResetTree"><i class="bi bi-eyeglasses"></i> Refocus tree</button>
                                </div>
                                <!--Zoom slider-->
                                <div data-toggle="tooltip" data-placement="top" title="Zoom in or out on the tree" class="d-flex flex-wrap align-items-center p-1">
                                    <small class="flex-grow-1" for="zoom_slider" class="form-label">Zoom</small>
                                    <div class="flex-grow-1 w-50">
                                        <input type="range" class="form-range align-middle"  id="zoom_slider" onchange="zoom_tree()" value="1" min="0.5" max="5" step="0.5">
                                    </div>
                                    <div class="flex-grow-1 fw-bold text-center">
                                        <span id="zoom_slider_value">1</span>x
                                    </div>    
                                </div>  
                                <!-- Decimal rounding -->
                                <div data-toggle="tooltip" data-placement="top" title="Specify the number of decimals to display." class="d-flex flex-wrap align-items-center p-1">
                                    <small class="flex-grow-1" for="decimal_rounding" class="form-label"># of decimals</small>
                                    <div class="flex-grow-1 w-50">
                                        <input type="range" class="form-range align-middle"  id="decimal-slider" onchange="round_decimals()" value=1 min="0" max="10" step="1">
                                    </div>
                                    <div class="flex-grow-1 fw-bold text-center">
                                        <span id="decimal-slider-value">1</span>
                                    </div>    
                                </div>  

                                <!--Slider for adjusting line thickness-->
                                <div data-toggle="tooltip" data-placement="top" title="Adjust line thickness" class="d-flex flex-wrap align-items-center p-1">
                                    <small class="flex-grow-1" for="zoom_slider" class="form-label">Line Weight</small>
                                    <div class="flex-grow-1 w-50">
                                        <input type="range" class="form-range align-middle"  id="line-thickness" onchange="lineThickness(this)" value="2.0" min="0.5" max="10.0" step="0.5">
                                    </div>
                                    <div class="flex-grow-1 fw-bold text-center">
                                        <span id="line-thickness-value">2.0</span>
                                    </div>    
                                </div> 

                                <div id="dropdown_tree_types" onclick="dropdownmenufix()" class="d-flex flex-wrap p-0 dropdown mb-1">
                                    <button id="tree_dropdown_menu"  class="btn btn-primary btn-sm dropdown-toggle w-100 text-wrap" type="button" data-toggle="tooltip" data-placement="top" title="List of fields to colour nodes by.">
                                        Select a tree layout</button>
                                </div> 
                                <!--button class="btn-sm btn-primary w-100 text-break mb-1" onclick="switchTreeType()" name="SwitchTree" id="switch-tree">Switch Tree</button-->   
                                <div id="legend-box" class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn the legend on or off">
                                    <small  class="flex-grow-1" for="legend_toggle">Legend</small>
                                    <input onchange="legend_on_off(this)" id="legend_toggle" 
                                    checked type="checkbox" data-toggle="toggle" data-onstyle="primary" data-size="sm">
                                </div> 
                                <div class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn branch lengths on or off" >
                                    <small data-toggle="tooltip" data-placement="top" title="Turn branch lengths on or off" class="flex-grow-1" for="legend_toggle">Branch lengths</small>
                                    <input onchange="branch_lengths_on_off(this)" id="branch_lengths_toggle" 
                                    checked type="checkbox" data-toggle="toggle" data-placement="top" title="Turn branch lengths on or off" data-onstyle="primary" data-size="sm">
                                </div>  
                                <div class="d-flex flex-wrap p-1 align-items-center text-left" data-toggle="tooltip" data-placement="top" title="Turn inner node labels on and off" >
                                    <small data-toggle="tooltip" data-placement="top" title="Turn inner node labels on and off" class="flex-grow-1" for="legend_toggle">Inner node labels</small>
                                    <input onchange="show_inner_node_labels(this)" id="inner_node_labels_toggle" 
                                    type="checkbox" data-toggle="toggle" data-placement="top" title="Turn inner node labels on and off" data-onstyle="primary" data-size="sm">
                                </div>  
                                <div id="dropdown_legend" onclick="dropdownmenufix()" class="d-flex flex-wrap p-0 dropdown mb-1">
                                    <button id="legend_dropdown_button" class="btn btn-danger btn-sm dropdown-toggle w-100 text-wrap" type="button" data-toggle="tooltip" data-placement="top" title="List of fields to colour nodes by.">
                                        Awaiting metadata</button>
                                </div> 
                                <div class="d-flex flex-row align-items-center p-0 text-left">
                                    <button data-toggle="tooltip" data-placement="top" title="Filter metadata for selected nodes" 
                                    class="flex-grow-1 btn-sm btn-primary text-break w-100 h-100 mb-1 me-1" name="SearchMetadata" id="metadata-search-button">
                                    <i class="bi bi-search icon-image"></i> Filter data</button>
                                    <button data-toggle="tooltip" data-placement="top" title="Clear all selected nodes." 
                                    class="flex-grow-1  btn-sm btn-primary text-break w-100 h-100 mb-1" name="ClearSelectedNodes" 
                                    onclick="clear_selected_nodes()" id="clear-selected-nodes"><i class="bi bi-x-square"></i> Clear Nodes</button>
                                </div>       
                    </div> 
            
                    <div data-toggle="tooltip" data-placement="top" title="Selected nodes on the tree will show up here." 
                      class="col border border-primary p-1 w-100 Tree inline-block-child scrollbar-window" 
                                id="SelectedNodes">
                        <div class="d-flex h-100 text-center text-uppercase text-center"><small class="align-self-center w-100">Selected Nodes</small></div>        
                    </div>
                </div> 


                <div class="position-relative p-0 bg-white col-10 Tree inline-block-child scrollbar-window" 
                onscroll="scroll_legend_into_view(document.querySelector('#colour-legend'), document.querySelector('#tree_fullscreen_btn'), this)"
                id="TreeData" style="height:70vh;">

                        <div id="tree-splash" class="fs-2 d-flex justify-content-center align-items-center" style="height:50vh;"><i class="bi bi-tree"></i> Your tree will show up here when loaded!</div>
                        
                        <div id="colour-legend"
                        class="d-none p-1 position-absolute border border-primary text-break Tree inline-block-child scrollbar-window" 
                        style="top:0px; left:0px; resize: both; max-height:100%; background-color: rgba(255, 255, 255, 0.9)">   
                        </div>
                        
                        <i style="position:absolute; top:0; right: 0; cursor: pointer; color:blue; margin-right:1px" id="tree_fullscreen_btn" 
                        onclick="tree_full_screen_mode()" class="d-flex fs-5 bi-arrow-up-right-square"></i>
                        
                </div> 

                </div>
                
                
            </div>
            <div class="row" style="height:5px;background-color: #0d6efd;">
                <a  href="#" data-bs-toggle="collapse" 
                data-bs-target="#ClusterInfo">
                </a>
                <div class="p-0" onmousedown="vertical_div_resize(event)" 
                style="position:absolute; cursor: ns-resize; box-shadow: 1px 1px 1px 1px rgba(0,0,0,.8); border-radius: 3px; left:50%; 
                background-color: #dc3545; width:50px; height:10px; z-index: 2;">
                </div>
            </div>
            <div id="ClusterInfo" class="row bg-white collapse show border border-primary w-100 m-0">
                <div class="col-12 p-0 overflow-auto" style="height:28.9vh">
                    <div id="table-splash" class="fs-2 d-flex justify-content-center align-items-center" style="height:25vh" ><i class="bi bi-file-spreadsheet"></i> Your metadata will go here when loaded!</div>
                    <table id="metadata" class="w-100 display overflow-scroll" >
                    </table>
                </div>    
            </div>
                
                <!-- Need to have the legend be scrollable and situated under the selected nodes-->
                
            
        </div> 
        <div id="TestSubTree"></div> 
        

    
    </body>
</html>
